library(quantmod)
library(dplyr)
library(tidyr)
library(openxlsx)
tickers <- c("AIG","AXP","BAC","C","COF","GS","JPM","MS","USB","WFC")
start_date <- as.Date("2024-12-26")
end_date   <- as.Date("2025-12-31")
get_adjclose <- function(sym, from, to) {
x <- suppressWarnings(
getSymbols(
Symbols = sym,
src = "yahoo",
from = from,
to = to,
auto.assign = FALSE,
adjusted = TRUE   # <-- IMPORTANT: ensure Adjusted column is fetched
)
)
# Explicitly grab the Adjusted column by name
adj_name <- paste0(sym, ".Adjusted")
if (!adj_name %in% colnames(x)) {
stop("Adjusted column not found for ", sym, ". Columns are: ", paste(colnames(x), collapse = ", "))
}
ad <- x[, adj_name]
data.frame(
Date = as.Date(index(ad)),
Ticker = sym,
AdjClose = as.numeric(ad)
)
}
adj_long <- bind_rows(lapply(tickers, get_adjclose, from = start_date, to = end_date)) %>%
arrange(Ticker, Date)
# Log returns computed from *Adjusted Close*
ret_long <- adj_long %>%
group_by(Ticker) %>%
mutate(Ret = log(AdjClose) - log(lag(AdjClose))) %>%
ungroup() %>%
filter(!is.na(Ret)) %>%
select(Date, Ticker, Ret) %>%
arrange(Date, Ticker)
library(quantmod)
library(dplyr)
library(tidyr)
library(openxlsx)
tickers <- c("AIG","AXP","BAC","C","COF","GS","JPM","MS","USB","WFC", "SST", "BK")
start_date <- as.Date("2024-12-26")
end_date   <- as.Date("2025-12-31")
get_adjclose <- function(sym, from, to) {
x <- suppressWarnings(
getSymbols(
Symbols = sym,
src = "yahoo",
from = from,
to = to,
auto.assign = FALSE,
adjusted = TRUE   # <-- IMPORTANT: ensure Adjusted column is fetched
)
)
# Explicitly grab the Adjusted column by name
adj_name <- paste0(sym, ".Adjusted")
if (!adj_name %in% colnames(x)) {
stop("Adjusted column not found for ", sym, ". Columns are: ", paste(colnames(x), collapse = ", "))
}
ad <- x[, adj_name]
data.frame(
Date = as.Date(index(ad)),
Ticker = sym,
AdjClose = as.numeric(ad)
)
}
adj_long <- bind_rows(lapply(tickers, get_adjclose, from = start_date, to = end_date)) %>%
arrange(Ticker, Date)
# Log returns computed from *Adjusted Close*
ret_long <- adj_long %>%
group_by(Ticker) %>%
mutate(Ret = AdjClose / lag(AdjClose) - 1) %>%
ungroup() %>%
filter(!is.na(Ret)) %>%
select(Date, Ticker, Ret) %>%
arrange(Date, Ticker)
# Export
file_out <- "returns_long.xlsx"
write.xlsx(ret_long, file = file_out, sheetName = "Returns", overwrite = TRUE)
dt_long <- read_excel('C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/data/data.xlsx')
dt_long
library(data.table)
library(rugarch)
library(readxl)
library(xts)
library(fGarch)
dt_long <- read_excel('C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/data/data.xlsx')
library(dplyr)
dt_long <- dt_long %>%
filter(Ticker %in% c("JPM","BAC", "C","MS","BK", "STT", "GS"))
dt_long <- as.data.table(dt_long)
dt_long[, Date := as.Date(Date, format = "%d/%m/%Y")]
dt_wide <- dcast(dt_long, Date ~ Ticker, value.var = "Ret")
setorder(dt_wide, Date)
ret_xts <- xts(dt_wide[, -1, with = FALSE], order.by = dt_wide$Date)
dt_long <- read_excel('C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/data/data.xlsx')
library(dplyr)
dt_long <- dt_long %>%
filter(Ticker %in% c("JPM","BAC", "C","MS","BK", "STT", "GS"))
dt_long <- as.data.table(dt_long)
dt_long[, Date := as.Date(Date, format = "%d/%m/%Y")]
dt_wide <- dcast(dt_long, Date ~ Ticker, value.var = "Ret")
setorder(dt_wide, Date)
ret_xts <- xts(dt_wide[, -1, with = FALSE], order.by = dt_wide$Date)
ret_xts <- xts(dt_wide[, -1], order.by = dt_wide$Date)
ret_xts <- log1p(ret_xts)
ret_xts
library(quantmod)
library(dplyr)
library(tidyr)
library(openxlsx)
tickers <- c("STT")
start_date <- as.Date("2024-12-31")
end_date   <- as.Date("2025-12-31")
get_adjclose <- function(sym, from, to) {
x <- suppressWarnings(
getSymbols(
Symbols = sym,
src = "yahoo",
from = from,
to = to,
auto.assign = FALSE,
adjusted = TRUE   # <-- IMPORTANT: ensure Adjusted column is fetched
)
)
# Explicitly grab the Adjusted column by name
adj_name <- paste0(sym, ".Adjusted")
if (!adj_name %in% colnames(x)) {
stop("Adjusted column not found for ", sym, ". Columns are: ", paste(colnames(x), collapse = ", "))
}
ad <- x[, adj_name]
data.frame(
Date = as.Date(index(ad)),
Ticker = sym,
AdjClose = as.numeric(ad)
)
}
adj_long <- bind_rows(lapply(tickers, get_adjclose, from = start_date, to = end_date)) %>%
arrange(Ticker, Date)
# Log returns computed from *Adjusted Close*
ret_long <- adj_long %>%
group_by(Ticker) %>%
mutate(Ret = AdjClose / lag(AdjClose) - 1) %>%
ungroup() %>%
filter(!is.na(Ret)) %>%
select(Date, Ticker, Ret) %>%
arrange(Date, Ticker)
# Export
file_out <- "returns_long.xlsx"
write.xlsx(ret_long, file = file_out, sheetName = "Returns", overwrite = TRUE)
library(data.table)
library(rugarch)
library(readxl)
library(xts)
library(fGarch)
################################################################################
## 1.  Load data & reshape                                                     ##
################################################################################
dt_long <- read_excel('C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/data/data.xlsx')
library(dplyr)
dt_long <- dt_long %>%
filter(Ticker %in% c("JPM","BAC", "C","MS","BK", "STT", "GS"))
dt_long <- as.data.table(dt_long)
dt_long[, Date := as.Date(Date, format = "%d/%m/%Y")]
dt_wide <- dcast(dt_long, Date ~ Ticker, value.var = "Ret")
setorder(dt_wide, Date)
ret_xts <- xts(dt_wide[, -1], order.by = dt_wide$Date)
ret_xts <- log1p(ret_xts)
# Excluding MS due to data issues and excluding one particular row wihtou values for all assets
#ret_xts <- ret_xts[, !colnames(ret_xts) %in% "MS"]
tickers <- colnames(ret_xts)
K       <- length(tickers)
# ---- SETTINGS ---------------------------------------------------------------
win_len     <- 504
refit_every <- 21
EXPECTED <- c("mu","ar1","omega","alpha1","beta1","skew","shape")
# Log failures here
fail_log <- data.table(asset = character(),
h = integer(),
date_t1 = as.Date(character()),
reason = character(),
conv_code = integer())
# last good parameters per asset (filled after initial fit)
last_good <- vector("list", K)
names(last_good) <- tickers
spec_norm <- ugarchspec(
variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model     = list(armaOrder = c(1, 0), include.mean = TRUE),  # AR(1)
distribution.model = "sstd"
)
# ---- small helpers ----------------------------------------------------------
default_pars <- function(x) {
# conservative defaults consistent with unconditional var
x <- as.numeric(x); x <- x[is.finite(x)]
v  <- var(x, na.rm = TRUE); if (!is.finite(v)) v <- 1e-6
alpha1 <- 0.05; beta1 <- 0.90
omega  <- max(1e-12, v * (1 - alpha1 - beta1))
c(mu = mean(x, na.rm = TRUE), ar1 = 0,
omega = omega, alpha1 = alpha1, beta1 = beta1,
skew = 1.0, shape = 8.0)
}
safe_coef <- function(fit) {
# return named vector in EXPECTED order, or NULL
if (is.null(fit) || inherits(fit, "try-error")) return(NULL)
if (isTRUE(fit@fit$convergence != 0)) return(NULL)
p <- (coef(fit))
p <- p[EXPECTED]
if (length(p) != length(EXPECTED) || any(!is.finite(p))) return(NULL)
p
}
spec_with_start <- function(start_pars) {
ugarchspec(
variance.model   = list(model = "sGARCH", garchOrder = c(1,1)),
mean.model       = list(armaOrder = c(1,0), include.mean = TRUE),
distribution.model = "sstd",
start.pars       = as.list(start_pars)   # warm start (free params)
)
}
spec_with_fixed <- function(pars) {
ugarchspec(
variance.model   = list(model = "sGARCH", garchOrder = c(1,1)),
mean.model       = list(armaOrder = c(1,0), include.mean = TRUE),
distribution.model = "sstd",
fixed.pars       = as.list(pars)         # use as-is (no optimization)
)
}
fit_garch_window_warm <- function(x, end_idx, start_pars = NULL) {
xw <- as.numeric(x[(end_idx - win_len + 1):end_idx])
stopifnot(all(is.finite(xw)))
sp <- if (is.null(start_pars)) spec_norm else spec_with_start(start_pars)
(
ugarchfit(
sp, data = xw,
solver = "hybrid",
solver.control = list(trace = 0),
fit.control = list(scale = TRUE, eval.se = FALSE)  # no Hessian
)
)
}
forecast_next_fixed <- function(pars, x_win) {
pars <- pars[EXPECTED]
sp   <- spec_with_fixed(pars)
fc   <- ugarchforecast(sp, data = as.numeric(x_win), n.ahead = 1)
c(mu    = as.numeric(fitted(fc)),
sigma = as.numeric(sigma(fc)),
df    = as.numeric(pars["shape"]),
xi    = as.numeric(pars["skew"]))
}
stdres_last_fixed <- function(pars, x_win_plus) {
pars <- pars[EXPECTED]
sp   <- spec_with_fixed(pars)
filt <- ugarchfilter(sp, data = as.numeric(x_win_plus))
tail(residuals(filt, standardize = TRUE), 1)
}
# ---- 1) INITIAL IN-SAMPLE FITS: fill last_good ------------------------------
ins_end <- win_len
garch_fit <- lapply(seq_along(tickers), function(i) {
fit_garch_window_warm(ret_xts[, i], end_idx = ins_end, start_pars = NULL)
})
names(garch_fit) <- tickers
# extract last_good; if missing, synthesize defaults from window
for (k in seq_len(K)) {
p <- safe_coef(garch_fit[[k]])
if (is.null(p)) {
xw <- ret_xts[(ins_end - win_len + 1):ins_end, k]
p  <- default_pars(xw)
fail_log <- rbind(
fail_log,
data.table(asset = tickers[k], h = 0,
date_t1 = index(ret_xts)[ins_end],
reason = "initial-fit/fallback-default", conv_code = NA_integer_)
)
}
last_good[[k]] <- p
}
# ---- 2) TRAINING PITs (optional) -------------------------------------------
pit_mat <- do.call(cbind, lapply(seq_len(K), function(k) {
z  <- residuals(garch_fit[[k]], standardize = TRUE)
nu <- last_good[[k]]["shape"]; xi <- last_good[[k]]["skew"]
psstd(z, mean = 0, sd = 1, nu = as.numeric(nu), xi = as.numeric(xi))
}))
colnames(pit_mat) <- tickers
pit_full <- xts(pit_mat, order.by = index(ret_xts)[1:win_len])
# ---- 3) ROLLING LOOP with warm start + logging + fallback -------------------
n_oos    <- nrow(ret_xts) - win_len
date_oos <- index(ret_xts)[(win_len + 1):(win_len + n_oos)]
df_fc     <- array(NA_real_, dim = c(n_oos, K), dimnames = list(NULL, tickers))
shape_fc  <- array(NA_real_, dim = c(n_oos, K), dimnames = list(NULL, tickers))
mu_fc     <- sigma_fc <- actual_ret <- array(NA_real_, dim = c(n_oos, K),
dimnames = list(NULL, tickers))
for (h in seq_len(n_oos)) {
t_idx     <- ins_end + h - 1       # last in-sample index (time t)
refit_now <- ((h - 1) %% refit_every) == 0
u_row     <- numeric(K)
for (k in seq_len(K)) {
# ---- 3.1 Refit (warm start) occasionally
if (refit_now) {
cat("Refitting in h equal to", h, "for asset", k, "\n")
start_pars <- last_good[[k]]
fit_k <- try(
fit_garch_window_warm(ret_xts[, k], end_idx = t_idx, start_pars = start_pars),
)
p_new <- safe_coef(fit_k)
if (is.null(p_new)) {
# log failure and keep previous params
fail_log <- rbind(
fail_log,
data.table(asset = tickers[k],
h = h,
date_t1 = index(ret_xts)[t_idx + 1],
reason = if (inherits(fit_k, "try-error")) "try-error" else "non-converged/invalid",
conv_code = if (inherits(fit_k, "try-error")) NA_integer_ else fit_k@fit$convergence)
)
} else {
last_good[[k]] <- p_new
}
}
# ---- 3.2 Forecast at t+1 using last_good (fixed.pars)
par_k  <- last_good[[k]]
x_win  <- ret_xts[(t_idx - win_len + 1):t_idx, k]
fc_val <- forecast_next_fixed(par_k, x_win)
mu_fc   [h, k] <- fc_val["mu"] # this is the forecast for this date h
sigma_fc[h, k] <- fc_val["sigma"]
df_fc   [h, k] <- fc_val["df"]
shape_fc[h, k] <- fc_val["xi"]
# realized r_{t+1}
actual_ret[h, k] <- coredata(ret_xts[t_idx + 1, k])
# ---- 3.3 PIT at t+1 using filtered std. residual under fixed params
x_win_plus <- ret_xts[(t_idx - win_len + 2):(t_idx + 1), k]
z_new      <- stdres_last_fixed(par_k, x_win_plus)
u_row[k]   <- psstd(z_new, mean = 0, sd = 1,
nu = as.numeric(df_fc[h, k]),
xi = as.numeric(shape_fc[h, k]))
}
pit_row_xts <- xts(t(u_row), order.by = index(ret_xts)[t_idx + 1])
colnames(pit_row_xts) <- tickers
pit_full <- rbind(pit_full, pit_row_xts)
print(h)
}
warnings()
# ---- 4) OPTIONAL: inspect/save failures ------------------------------------
if (nrow(fail_log)) {
print(fail_log)
# saveRDS(fail_log, file = file.path("data", "garch_refit_failures.rds"))
}
fail_log
date_col <- data.table(Date = date_oos)
# realised returns  r_t              →  ./data/returns_actual.rds
actual_dt <- cbind(date_col, as.data.table(actual_ret))
actual_dt
# realised returns  r_t              →  ./data/returns_actual.rds
actual_dt <- cbind(date_col, as.data.table(actual_ret))
saveRDS(actual_dt, file = file.path("data", "returns_actual.rds"))
# forecast means   μ̂_{t|t-1}        →  ./data/returns_mean_forecast.rds
mean_dt   <- cbind(date_col, as.data.table(mu_fc))
saveRDS(mean_dt,   file = file.path("data", "returns_mean_forecast.rds"))
# forecast vols    σ̂_{t|t-1}        →  ./data/returns_vol_forecast.rds
sigma_dt  <- cbind(date_col, as.data.table(sigma_fc))
saveRDS(sigma_dt,  file = file.path("data", "returns_vol_forecast.rds"))
df_fc  <- cbind(date_col, as.data.table(df_fc))
saveRDS(df_fc,  file = file.path("data", "df_fc.rds"))
shape_fc  <- cbind(date_col, as.data.table(shape_fc))
saveRDS(shape_fc,  file = file.path("data", "shape_fc.rds"))
## ------------ persist to disk ----------------------------------------------
saveRDS(pit_full,  file = file.path("data", "PIT.rds"))
saveRDS(index(ret_xts), file = file.path("data", "dates.rds"))
library(here)
source(here("src/R", "config.R"))
dat <- import_data(drop_first_col = TRUE, n_assets = 7)
#cfg_variants <- list(list(label = "test"))
cfg_variants <- list(
#list(label = "std", q_flip = 0.2),
#list(label = "tailW_tauL0.2_taileps0.5",  use_weighted_ll = TRUE,
#     tauL = 0.2, joint_k = 2L, tail_eps = 0.50, q_flip = 0.2),
#list(label = "tailW_tauL0.1_taileps0.3",  use_weighted_ll = TRUE,
#     tauL = 0.1, joint_k = 2L, tail_eps = 0.30, q_flip = 0.2),
# list(label = "tip_w252_M2000_tipk10",  use_tail_informed_prior = TRUE, W = 252L, M=2000L, tip_k=25),#, q_flip = 0.2)
# list(label = "tip_w252_M2000_tipk5",  use_tail_informed_prior = TRUE, W = 252L, M=2000L, tip_k=13),
# list(label = "tip_w252_M2000_tipk15",  use_tail_informed_prior = TRUE, W = 252L, M=2000L, tip_k=38),
#
# list(label = "tip_w126_M2000_tipk10",  use_tail_informed_prior = TRUE, W = 126L, M=2000L, tip_k=13),#, q_flip = 0.2)
# list(label = "tip_w126_M2000_tipk5",  use_tail_informed_prior = TRUE,  W = 126L, M=2000L, tip_k=6),
# list(label = "tip_w126_M2000_tipk15",  use_tail_informed_prior = TRUE, W = 126L, M=2000L, tip_k=19),
#
# list(label = "tip_w504_M2000_tipk10",  use_tail_informed_prior = TRUE, W = 504L, M=2000L, tip_k=50),#, q_flip = 0.2)
# list(label = "tip_w504_M2000_tipk5",  use_tail_informed_prior = TRUE, W = 504L, M=2000L, tip_k=25),
# list(label = "tip_w504_M2000_tipk15",  use_tail_informed_prior = TRUE, W = 504L, M=2000L, tip_k=76)
list(label = "tip_w252_M2000_tip",  use_tail_informed_prior = TRUE, W = 252L, M=2000L),#, q_flip = 0.2)
list(label = "tip_w126_M2000_tip",  use_tail_informed_prior = TRUE, W = 126L, M=2000L),#, q_flip = 0.2)
list(label = "tip_w504_M2000_tip",  use_tail_informed_prior = TRUE, W = 504L, M=2000L)#, q_flip = 0.2)
)
v
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
U      <- data$U
M <- cfg$M; K <- cfg$K; N <- nrow(U); d <- cfg$d; n_oos <- N - cfg$W_predict
tickers    <- colnames(U); A <- length(cfg$alphas); t_train <- cfg$W_predict
mu_fc   <- data$mu_fc[(nrow(data$mu_fc)   - n_oos + 1):nrow(data$mu_fc), , drop = FALSE]
sig_fc  <- data$sig_fc[(nrow(data$sig_fc) - n_oos + 1):nrow(data$sig_fc), , drop = FALSE]
df_fc   <- data$df_fc[(nrow(data$df_fc)   - n_oos + 1):nrow(data$df_fc), , drop = FALSE]
shape_fc<- data$shape_fc[(nrow(data$shape_fc) - n_oos + 1):nrow(data$shape_fc), , drop = FALSE]
y_real  <- data$y_real[(nrow(data$y_real) - n_oos + 1):nrow(data$y_real), , drop = FALSE]
cfg$trunc_tree
U[1:t_train, ]
structure = NULL
trunc_tree
trunc_tree=6
CVM <- RVineStructureSelect(
U_train, familyset = c(1), type = 1,
indeptest = TRUE, level = 0.1,
trunclevel = trunc_tree                                   # NEW
)
U_train <- U[1:t_train, ]
CVM <- RVineStructureSelect(
U_train, familyset = c(1), type = 1,
indeptest = TRUE, level = 0.1,
trunclevel = trunc_tree                                   # NEW
)
old_M  <- CVM$Matrix
order  <- old_M[, 1]
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = NA                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 1                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 2                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 3                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 4                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 5                                 # NEW
)
skeleton
skeleton$pair_copulas
CVM
CVM <- RVineStructureSelect(
U_train, familyset = c(1), type = 1,
indeptest = TRUE, level = 0.2,
trunclevel = trunc_tree                                   # NEW
)
CVM
CVM <- RVineStructureSelect(
U_train, familyset = c(1), type = 1,
indeptest = TRUE, level = 0.1,
trunclevel = trunc_tree                                   # NEW
)
old_M  <- CVM$Matrix
order  <- old_M[, 1]
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 5                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 6                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 4                                 # NEW
)
skeleton
skeleton <- vinecop(
U_train,
family_set = c("gaussian"),
structure = cvine_structure(order),
trunc_lvl = 3                                 # NEW
)
skeleton
