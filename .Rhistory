draws <- smc_predictive_sample(particles, skeleton, w/sum(w), L = 5000, cl = cl)
Z_pred <- st_inv_fast(draws, shape_fc[t, ], df_fc[t, ])
R_t  <- sweep(Z_pred, 2, as.numeric(sig_fc[t, ]), `*`) + as.numeric(mu_fc[t, ])          # L × d
rs <- risk_stats_full(
R_t,
cfg$alphas)
out$risk$dates[idx]   <- t
out$risk$mean [idx, ] <- rs$mean
out$risk$var  [idx, ] <- rs$var
out$risk$ci_lo[idx, ] <- rs$ci["lo", ]
out$risk$ci_hi[idx, ] <- rs$ci["hi", ]
out$risk$VaR [idx, , ] <- rs$VaR          # d × A
out$risk$ES  [idx, , ] <- rs$ES
# EW-portfolio metrics
r_p  <- rowMeans(R_t)
ps   <- port_stats(r_p, cfg$alphas)
out$port$dates[idx]   <- t
out$port$mean [idx]   <- ps$mu
out$port$VaR [idx, ]  <- ps$VaR
out$port$ES  [idx, ]  <- ps$ES
}
# diagnostics
dg <- diagnostic_report(t, 0, U, particles, w, cfg)
out$diag_log[t, `:=`(t        = t,
ESS      = dg$ESS,
unique   = dg$unique,
euc      = dg$euc,
sparsity = dg$sparsity)]
newAnc <- stratified_resample(w)
data_up_to_t <- U[max(1, t - cfg$W + 1):t, , drop = FALSE]
newAncestors <- newAnc
#idx       <- sample.int(M, M, TRUE, prob = w_new)
particles <- particles[newAncestors]                  # cópia simples
for (p in particles) {                       # reinicia pesos
p$w <- 1 / cfg$M
}
mh_n_prop <- cfg$M * cfg$n_mh
mh_n_acc  <- 0
particles_local=particles
i=1
p <- particles_local[[i]]
local_acc <- 0L
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
log_acc
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
i=2
p <- particles_local[[i]]
local_acc <- 0L
k
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
aux <- log(runif(1))
log_acc
aux
i=3
p <- particles_local[[i]]
local_acc <- 0L
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
### Add conditional such that if any entri is nan do not accept
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
print(log_acc)
aux <- log(runif(1))
if (aux < log_acc) {
prop$last_accept <- TRUE
return(prop)
} else {
p$last_accept <- FALSE
return(p)
}
}
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
### Add conditional such that if any entri is nan do not accept
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
print(log_acc)
print(ll_prop)
print(log_prior(prop, cfg))
print(ll_curr)
print(log_prior(p,    cfg))
aux <- log(runif(1))
if (aux < log_acc) {
prop$last_accept <- TRUE
return(prop)
} else {
p$last_accept <- FALSE
return(p)
}
}
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
### Add conditional such that if any entri is nan do not accept
log_prior(prop, cfg)
prop = p
p=prop
lam <- bb1_par2tail(th1, th2)
fam = p$fam
th1 = p$th1
th2 = p$th2
lam <- bb1_par2tail(th1, th2)
lp_tail <- dbeta(lam[1], 2, 2, log=TRUE) +
dbeta(lam[2], 2, 2, log=TRUE)
lp <- lp_tail + bb1_log_jacobian(lam[1], lam[2]) - 2*cfg$lambda
lp
lp_tail
bb1_log_jacobian(lam[1], lam[2]) - 2*cfg$lambda
2*cfg$lambda
bb1_log_jacobian(lam[1], lam[2])
fillna_neg(lp)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/scripts/run_empirical.R", echo=TRUE)
library(sn)
renv::status()
renv::snapshot(type = "all")
renv::status()
renv::snapshot(type = "all")   # safest catch-all
renv::status()
miss <- subset(st$inconsistent, recorded == "n")$package
st  <- renv::status()          # invisible list with a data.frame of issues
miss <- subset(st$inconsistent, recorded == "n")$package
