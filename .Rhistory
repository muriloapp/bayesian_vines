prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps)))
ll_curr <- sum(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps)))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
if (log(runif(1)) < log_acc) {
prop$last_accept <- TRUE
return(list(prop))
} else {
p$last_accept <- FALSE
return(p)
}
}, error = function(e) {
## ----------  diagnostic dump  ----------
message("\n--- mh_step ERROR DIAGNOSTICS ---")
message("ll_prop    = ", ll_prop)
message("prior_prop = ", prior_prop)
message("ll_curr    = ", ll_curr)
message("prior_curr = ", prior_curr)
message("log_acc    = ", log_acc)
message("log(u)     = ", u)
message("--- end diagnostics --------------\n")
## Re-throw so the calling code can still fail gracefully
stop(e)
})
}
u_t <- U[t,,drop=FALSE]
# weight-update
log_inc <- compute_log_incr(particles, u_t, skeleton, cfg)
particles <- update_weights(particles, log_inc)
w <- vapply(particles, `[[`, numeric(1), "w")
# prediction block
if (t > cfg$W_predict) {
# log predictive density, predictive draws, risk metrics
idx <- t - cfg$W_predict
out$log_pred[t] <- compute_predictive_metrics(u_t, particles, skeleton, w/sum(w), cfg)$log_pred_density
draws <- smc_predictive_sample(particles, skeleton, w/sum(w), L = 10000, cl = cl)
Z_pred <- t_inv(draws, df_fc[t, ])
rs <- risk_stats_full(            # same helper as before
Z_pred,
mu_fc[t, , drop = TRUE],
sig_fc[t, , drop = TRUE],
cfg$alphas)
out$risk$dates[idx]   <- t
out$risk$mean [idx, ] <- rs$mean
out$risk$var  [idx, ] <- rs$var
out$risk$ci_lo[idx, ] <- rs$ci["lo", ]
out$risk$ci_hi[idx, ] <- rs$ci["hi", ]
out$risk$VaR [idx, , ] <- rs$VaR          # dim = d × A
out$risk$ES  [idx, , ] <- rs$ES
# ---------- EW-portfolio metrics -------------------
R_t  <- sweep(Z_pred, 2, as.numeric(sig_fc[t, ], `*`)) + as.numeric(mu_fc[t, ])          # L × d
r_p  <- rowMeans(R_t)                                            # ← NEW (L)
ps   <- port_stats(r_p, cfg$alphas)                              # ← NEW
out$port$dates[idx]   <- t                                       # ← NEW
out$port$mean [idx]   <- ps$mu
out$port$VaR [idx, ]  <- ps$VaR
out$port$ES  [idx, ]  <- ps$ES
}
# diagnostics
dg <- diagnostic_report(t, 0, U, particles, w, cfg)
out$diag_log[t, `:=`(t        = t,
ESS      = dg$ESS,
unique   = dg$unique,
euc      = dg$euc,
sparsity = dg$sparsity)]
newAnc <- stratified_resample(w)
data_up_to_t <- U[max(1, t - cfg$W + 1):t, , drop = FALSE]
newAncestors <- newAnc
## --- 1a.  Resample ------------------------------------------------
particles <- particles[newAncestors]        # simple copy
for (p in particles) p$w <- 1 / cfg$M       # reset weights
## --- 1b.  Ship particles ONCE to each worker ----------------------
clusterExport(cl, "particles")
## Pre-allocate the output container
serial_test <- vector("list", length(particles))
## Outer loop over particles
for (i in seq_along(particles)) {
p <- particles[[i]]           # current particle
local_acc <- 0L               # acceptance counter (optional)
## Optional: announce which particle we’re on
# cat(sprintf("\n---- Particle %d ----\n", i))
## Inner loop: Metropolis-Hastings steps
for (k in seq_len(cfg$n_mh)) {
## Insert a browser() here if you want to step through interactively
# if (i == 1 && k == 1) browser()
p <- mh_step(p, data_up_to_t, skeleton, cfg)
## Count acceptances (defensive against NA)
if (!is.null(p$last_accept) && isTRUE(p$last_accept)) {
local_acc <- local_acc + 1L
}
## Optional: verbose progress every, say, 10 iterations
# if (k %% 10 == 0)
#   cat(sprintf("particle %d | iter %4d | last_accept = %s | acc = %d\n",
#               i, k, p$last_accept, local_acc))
}
## Store the final particle (and maybe the acc counter)
serial_test[[i]] <- p
# attr(serial_test[[i]], "n_accept") <- local_acc   # if you’d like the counter
## Optional: quick summary per particle
# cat(sprintf("particle %d finished: %d / %d MH accepts\n",
#             i, local_acc, cfg$n_mh))
}
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
## (a) family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx]
allowed_names <- if (tr_idx == 1)
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
## choose a different family *within* the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps)))
ll_curr <- sum(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps)))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
cat(sprintf(
" ll_prop = % .6f | prior_prop = % .6f | ",
ll_prop, prior_prop))
cat(sprintf(
"ll_curr = % .6f | prior_curr = % .6f | log_acc = % .6f | ",
ll_curr, prior_curr, log_acc))
if (log(runif(1)) < log_acc) {
prop$last_accept <- TRUE
return(list(prop))
} else {
p$last_accept <- FALSE
return(p)
}
}
## Pre-allocate the output container
serial_test <- vector("list", length(particles))
## Outer loop over particles
for (i in seq_along(particles)) {
p <- particles[[i]]           # current particle
local_acc <- 0L               # acceptance counter (optional)
## Optional: announce which particle we’re on
# cat(sprintf("\n---- Particle %d ----\n", i))
## Inner loop: Metropolis-Hastings steps
for (k in seq_len(cfg$n_mh)) {
## Insert a browser() here if you want to step through interactively
# if (i == 1 && k == 1) browser()
p <- mh_step(p, data_up_to_t, skeleton, cfg)
## Count acceptances (defensive against NA)
if (!is.null(p$last_accept) && isTRUE(p$last_accept)) {
local_acc <- local_acc + 1L
}
## Optional: verbose progress every, say, 10 iterations
# if (k %% 10 == 0)
#   cat(sprintf("particle %d | iter %4d | last_accept = %s | acc = %d\n",
#               i, k, p$last_accept, local_acc))
}
## Store the final particle (and maybe the acc counter)
serial_test[[i]] <- p
# attr(serial_test[[i]], "n_accept") <- local_acc   # if you’d like the counter
## Optional: quick summary per particle
# cat(sprintf("particle %d finished: %d / %d MH accepts\n",
#             i, local_acc, cfg$n_mh))
}
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
## (a) family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx]
allowed_names <- if (tr_idx == 1)
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
## choose a different family *within* the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps)))
ll_curr <- sum(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps)))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
cat(sprintf(
" ll_prop = % .6f | prior_prop = % .6f | ",
ll_prop, log_prior(prop, cfg)))
cat(sprintf(
"ll_curr = % .6f | prior_curr = % .6f | log_acc = % .6f | ",
ll_curr, log_prior(p,    cfg), log_acc))
if (log(runif(1)) < log_acc) {
prop$last_accept <- TRUE
return(list(prop))
} else {
p$last_accept <- FALSE
return(p)
}
}
## Pre-allocate the output container
serial_test <- vector("list", length(particles))
## Outer loop over particles
for (i in seq_along(particles)) {
p <- particles[[i]]           # current particle
local_acc <- 0L               # acceptance counter (optional)
## Optional: announce which particle we’re on
# cat(sprintf("\n---- Particle %d ----\n", i))
## Inner loop: Metropolis-Hastings steps
for (k in seq_len(cfg$n_mh)) {
## Insert a browser() here if you want to step through interactively
# if (i == 1 && k == 1) browser()
p <- mh_step(p, data_up_to_t, skeleton, cfg)
## Count acceptances (defensive against NA)
if (!is.null(p$last_accept) && isTRUE(p$last_accept)) {
local_acc <- local_acc + 1L
}
## Optional: verbose progress every, say, 10 iterations
# if (k %% 10 == 0)
#   cat(sprintf("particle %d | iter %4d | last_accept = %s | acc = %d\n",
#               i, k, p$last_accept, local_acc))
}
## Store the final particle (and maybe the acc counter)
serial_test[[i]] <- p
# attr(serial_test[[i]], "n_accept") <- local_acc   # if you’d like the counter
## Optional: quick summary per particle
# cat(sprintf("particle %d finished: %d / %d MH accepts\n",
#             i, local_acc, cfg$n_mh))
}
k
i
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
## (a) family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx]
allowed_names <- if (tr_idx == 1)
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
## choose a different family *within* the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps)))
ll_curr <- sum(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps)))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
if (log(runif(1)) < log_acc) {
prop$last_accept <- TRUE
return(list(prop))
} else {
p$last_accept <- FALSE
return(p)
}
}
## Pre-allocate the output container
serial_test <- vector("list", length(particles))
## Outer loop over particles
for (i in seq_along(particles)) {
p <- particles[[i]]           # current particle
local_acc <- 0L               # acceptance counter (optional)
## Optional: announce which particle we’re on
# cat(sprintf("\n---- Particle %d ----\n", i))
## Inner loop: Metropolis-Hastings steps
for (k in seq_len(cfg$n_mh)) {
## Insert a browser() here if you want to step through interactively
# if (i == 1 && k == 1) browser()
p <- mh_step(p, data_up_to_t, skeleton, cfg)
## Count acceptances (defensive against NA)
if (!is.null(p$last_accept) && isTRUE(p$last_accept)) {
local_acc <- local_acc + 1L
}
## Optional: verbose progress every, say, 10 iterations
# if (k %% 10 == 0)
#   cat(sprintf("particle %d | iter %4d | last_accept = %s | acc = %d\n",
#               i, k, p$last_accept, local_acc))
}
## Store the final particle (and maybe the acc counter)
serial_test[[i]] <- p
# attr(serial_test[[i]], "n_accept") <- local_acc   # if you’d like the counter
## Optional: quick summary per particle
# cat(sprintf("particle %d finished: %d / %d MH accepts\n",
#             i, local_acc, cfg$n_mh))
}
library(here)
source(here("src/R", "config.R"))
data <- list(
U      = readRDS("data/PIT.rds")[1:756*2,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[1:756*2,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[1:756*2,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[1:756*2,2:4]#[,-1]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
dat <- list(
U      = readRDS("data/PIT.rds")[1:756*2,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[1:756*2,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[1:756*2,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[1:756*2,2:4]#[,-1]
)
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
library(here)
source(here("src/R", "config.R"))
dat <- list(
U      = readRDS("data/PIT.rds")[1:756*2,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[1:756*2,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[1:756*2,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[1:756*2,2:4]#[,-1]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
library(here)
source(here("src/R", "config.R"))
dat <- list(
U      = readRDS("data/PIT.rds")[1:756*2,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[1:756*2,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[1:756*2,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[1:756*2,2:4]#[,-1]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
dat <- list(
U      = readRDS("data/PIT.rds")[1:756*2,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[1:756*2,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[1:756*2,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[1:756*2,2:4]#[,-1]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
library(here)
source(here("src/R", "config.R"))
