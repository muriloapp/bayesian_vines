combined_plot <- wrap_plots(plots, ncol = 2)
combined_plot
ggsave(filename = "figures/static_8d_tr4_theta.png", plot = combined_plot, width = 12, height = 12)
true_values_list <- rev(list(0,0,0,0))
p <- 18
plots <- lapply(seq_along(true_values_list), function(k) {
df_mean <- data.frame(
block = res_block$gamma_mean[, k+p],
stand = res_stand$gamma_mean[, k+p]
)
df_se <- data.frame(
block = res_block$gamma_se[, k+p],
stand = res_stand$gamma_se[, k+p]
)
plot_theta_paths_df(
theta_mean = df_mean,
theta_sd   = df_se,
theta_true = true_values_list[[k]],
legend_labels = c("Tempering", "Standard"),
plot_title = bquote("Posterior path of " * gamma[.(k)])
)
})
# Add empty placeholders to fill 3x3 layout
while (length(plots) < 4) {
plots[[length(plots) + 1]] <- patchwork::plot_spacer()
}
# Combine and display in a 3x3 grid
combined_plot <- wrap_plots(plots, ncol = 2)
combined_plot
ggsave(filename = "figures/static_8d_tr4_gamma.png", plot = combined_plot, width = 12, height = 12)
df_ESS <- data.frame(
block = res_block$diag_log$ESS,
stand = res_stand$diag_log$ESS,
threshold = rep(1000, length( res_stand$diag_log$ESS))
)
sum(res_block$diag_log$ESS<1000)
sum(res_stand$diag_log$ESS<1000)
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size (Hits: 17 for standard and 22 for blocks)")
df_ESS
df_ESS <- na.omit(df_ESS)
dim(df_ESS)
df_ESS <- df_ESS[df_ESS$column_name != 0, ]
dim(df_ESS)
df_ESS <- data.frame(
block = res_block$diag_log$ESS,
stand = res_stand$diag_log$ESS,
threshold = rep(1000, length( res_stand$diag_log$ESS))
)
df_ESS <- df_ESS[rowSums(df_ESS != 0) > 0, ]
dim(df_ESS)
df_ESS[2998:3001]
df_ESS[2998:3001,1]
df_ESS[2998:3001,]
df_ESS[1:3,]
df_ESS <- df_ESS[1:3000,]
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size (Hits: 17 for standard and 22 for blocks)")
sum(df_ESS$block>1000)
sum(df_ESS$block<1000)
sum(df_ESS$stand<1000)
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size (Hits: 231 for standard and 169 for blocks)")
ggsave(filename = "figures/static_8d_ESS.png", plot = p, width = 8, height = 6)
df_unique <- data.frame(
block = res_block$diag_log$unique,
stand = res_stand$diag_log$unique,
initial_value = rep(1000, length( res_stand$diag_log$unique))
)
p <- plot_theta_paths_df(df_unique,  plot_title = "Unique number of particles")
df_ESS <- data.frame(
#block = res_block$diag_log$ESS,
stand = res_stand$diag_log$ESS,
threshold = rep(1000, length( res_stand$diag_log$ESS))
)
df_ESS
df_ESS <- data.frame(
#block = res_block$diag_log$ESS,
stand = res_stand$diag_log$ESS,
threshold = rep(1000, length( res_stand$diag_log$ESS))
)
sum(df_ESS$stand<1000)
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size - 77 hits")
ggsave(filename = "figures/static_8d_ESS_stand.png", plot = p, width = 8, height = 6)
df_ESS <- data.frame(
block = res_block$diag_log$ESS,
#stand = res_stand$diag_log$ESS,
threshold = rep(3000, length( res_stand$diag_log$ESS))
)
df_ESS
df_ESS <- df_ESS[1:3000,]
sum(df_ESS$stand<1000)
sum(df_ESS$block<1000)
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size - 169 hits")
df_ESS <- data.frame(
block = res_block$diag_log$ESS,
#stand = res_stand$diag_log$ESS,
threshold = rep(1000, length( res_stand$diag_log$ESS))
)
df_ESS <- df_ESS[1:3000,]
sum(df_ESS$block<1000)
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size - 169 hits")
library(here)
source(here::here("src","config.R"))
p <- plot_theta_paths_df(df_ESS,  plot_title = "Effective Sample Size - 169 hits")
ggsave(filename = "figures/static_8d_ESS_block.png", plot = p, width = 8, height = 6)
df_unique <- data.frame(
#block = res_block$diag_log$unique,
stand = res_stand$diag_log$unique,
initial_value = rep(2000, length( res_stand$diag_log$unique))
)
p <- plot_theta_paths_df(df_unique,  plot_title = "Unique number of particles")
ggsave(filename = "figures/static_3d_unique_stand.png", plot = p, width = 8, height = 6)
df_unique <- data.frame(
block = res_block$diag_log$unique,
#stand = res_stand$diag_log$unique,
initial_value = rep(2000, length( res_stand$diag_log$unique))
)
p <- plot_theta_paths_df(df_unique,  plot_title = "Unique number of particles")
df_unique <- df_unique[1:3000,]
p <- plot_theta_paths_df(df_unique,  plot_title = "Unique number of particles")
ggsave(filename = "figures/static_3d_unique_block.png", plot = p, width = 8, height = 6)
res_stand$log_model_evidence
res_block$log_model_evidence
res_stand <- readRDS("simul_results/static_dgp/standard_stat_3.rds")
res_block <- readRDS("simul_results/static_dgp/block_stat_3.rds")
res_stand$log_model_evidence
res_block$log_model_evidence
1886/1797-1
291/285
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
warnings()
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
new_particle <- function(cfg) {
with(cfg, {
g <- rbinom(K, 1, 1 - pi0_edge)
tvec <- rnorm(K, 0, slab_sd) * g
list(gamma = g, theta = tvec, w = 1 / M, last_accept = NA)
})
}
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
rnorm(1,0,0.05)
rnorm(1,0,0.05)
rnorm(1,0,0.05)
rnorm(1,0,0.05)
rnorm(1,0,0.05)
rnorm(1,0,0.02)
rnorm(1,0,0.02)
rnorm(1,0,0.02)
rnorm(1,0,0.02)
rnorm(1,0,0.02)
rnorm(1,0,0.02)
rnorm(1,0,0.02)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
res_stand <- readRDS("simul_results/static_dgp/standard_8_pi05_G3_N50_SSVSc")
library(here)
source(here::here("src","config.R"))
res_stand <- readRDS("simul_results/static_dgp/standard_8_pi05_G3_N50_SSVSc")
res_stand$
plot_theta_paths(res_stand$theta_mean, res_stand$theta_se, k=1, theta_true = 0.5)
res_stand$theta_mean
res_stand$theta_mean
res_stand$theta_se
plot_theta_paths(res_stand$theta_mean, res_stand$theta_se, k=1, theta_true = 0.5)
plot_theta_paths(res_stand$theta_mean, res_stand$theta_se, k=2, theta_true = 0.5)
# plot(results$diag_log$unique, type="l")
#
plot_genealogy_theta(results$theta_hist, results$ancestorIndices, edge_id = 1, ylim = c(0.5, 1.1))
# plot(results$diag_log$unique, type="l")
#
plot_genealogy_theta(res_stand$theta_hist, res_stand$ancestorIndices, edge_id = 1, ylim = c(0.5, 1.1))
# plot(results$diag_log$unique, type="l")
#
plot_genealogy_theta(res_stand$theta_hist, res_stand$ancestorIndices, edge_id = 1)
# plot(results$diag_log$unique, type="l")
#
plot_genealogy_theta(res_stand$theta_hist, res_stand$ancestorIndices, edge_id = 2)
# plot(results$diag_log$unique, type="l")
#
plot_genealogy_theta(res_stand$theta_hist, res_stand$ancestorIndices, edge_id = 3)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
skeleton  <- vinecop(U, family_set = "gaussian")
skeleton
skeleton$pair_copulas
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
library(here)
source(here::here("src","config.R"))
library(here)
source(here::here("src","config.R"))
res_stand <- readRDS("simul_results/static_dgp/standard_3_pi05_nmh1_N250_KM")
plot_theta_paths(res_stand$theta_mean, res_stand$theta_se, k=1, theta_true = 0.6)
res_SS <- readRDS("simul_results/static_dgp/standard_3_pi05_nmh1_N250_SSVS")
plot_theta_paths(res_SS$theta_mean, res_SS$theta_se, k=1, theta_true = 0.6)
plot_theta_paths(res_stand$theta_mean, res_stand$theta_se, k=2, theta_true = 0.4)
plot_theta_paths(res_SS$theta_mean, res_SS$theta_se, k=2, theta_true = 0.4)
plot_theta_paths(res_stand$theta_mean, res_stand$theta_se, k=3, theta_true = 0.2)
plot_theta_paths(res_SS$theta_mean, res_SS$theta_se, k=3, theta_true = 0.2)
library(here)
source(here::here("src","config.R"))
set.seed(126)
U  <- sim_static_cop_3(N = 250)
d  <- ncol(U)
n_cores    = max(parallel::detectCores() - 1, 1)
skeleton  <- vinecop(U, family_set = "gaussian")
# ── dimensions ───────────────────────────────────────────────────
N <- nrow(U); K <- cfg$K; M <- cfg$M
cfg_variants <- list(
list(
pi0_edge   = 0.50,
label      = "pi05_nmh1_N250_SSVS",
n_mh       = 1
) #,
# list(
#   pi0_edge   = 0.70,
#   W          = 30,
#   label      = "pi07_W30"
# )
)
seq_along(cfg_variants)
i=1
v    <- cfg_variants[[i]]          # pull the i-th inner list
tag  <- v[["label"]]               # safe even if names = NULL
tweaks <- v[ setdiff(names(v), "label") ]   # drop label for merging
cfg    <- modifyList(build_cfg(d), tweaks)
cfg
# ── dimensions ───────────────────────────────────────────────────
N <- nrow(U); K <- cfg$K; M <- cfg$M
# ── pre-allocate diagnostics ───────────────────────────────────────────────
out <- list(
log_pred   = numeric(N),
theta_mean = matrix(NA_real_, N, K),
theta_se   = matrix(NA_real_, N, K),
#gamma_mean = matrix(NA_real_, N, K),
#gamma_se   = matrix(NA_real_, N, K),
diag_log   = data.table::data.table(
t      = integer(N),
tr     = integer(N),
ESS    = numeric(N),
unique = integer(N),
euc    = numeric(N)
),
mh_acc_pct      = rep(NA_real_, N),
theta_hist      = array(NA_real_,    dim = c(M, N, K)),
#gamma_hist      = array(NA_integer_, dim = c(M, N, K)),
ancestorIndices = matrix(0L, M, N),
incl_hist = matrix(NA_real_, N, K)
)
cfg$spike_sd
# ── initial state ──────────────────────────────────────────────────────────
particles <- replicate(M, new_particle(cfg), simplify = FALSE)
particles
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
rnorm(1,0,0.04)
out$ancestorIndices[, 1] <- seq_len(M)
tr  <- 0L        #  “tree” counter — keep if you resample by tree else 0
pos <- 1L        #  row pointer for diag_log
# ── parallel backend ───────────────────────────────────────────────────────
cl <- parallel::makeCluster(n_cores)
on.exit(parallel::stopCluster(cl), add = TRUE)          # safe cleanup
parallel::clusterSetRNGStream(cl, cfg$seed)
parallel::clusterExport(
cl,
c("mh_step_in_tree", "vine_from_particle", "log_prior",
"bicop_dist", "vinecop_dist", "dvinecop", "skeleton", "cfg",
"mh_step", "propagate_particles", "update_weights", "ESS",
"diagnostic_report", "systematic_resample", "resample_move",
"compute_predictive_metrics", "compute_log_incr"),
envir = environment()
)
t_idx=1
u_row <- U[t_idx, , drop = FALSE]
u_row
# 3. weight update ──────────────────────────────────────────────────────
log_incr  <- compute_log_incr(particles, u_row, skeleton, cfg)
particles <- update_weights(particles, log_incr)
w_new     <- vapply(particles, `[[`, numeric(1), "w")
cfg$k_step
cfg$M
k_step <- cfg$k_step
M <- cfg$M
## 1. unpack particle state -------------------------------------------------
#gamma_mat <- do.call(rbind, lapply(particles, `[[`, "gamma"))
theta_mat <- do.call(rbind, lapply(particles, `[[`, "theta"))
theta_mat
rho_mat   <- tanh(theta_mat)
rho_mat
responsibility(theta_mat, cfg)
slab_w <- responsibility(theta_mat, cfg)   # M × K
## 2. normalise weights (essential) -----------------------------------------
w_new <- w_new / sum(w_new)
ess_t <- 1 / sum(w_new^2)
## 3. global diagnostics ----------------------------------------------------
edge_ct    <- rowSums(slab_w)
edge_ct
mean_edges <- w_mean(edge_ct, w_new)
mean_edges
se_edges   <- mc_se(edge_ct, w_new, ess_t)
key_vec   <- apply(cbind(slab_w, theta_mat), 1L,
\(row) paste(row, collapse = ","))
key_vec
n_unique  <- length(unique(key_vec))
n_unique
dists     <- as.matrix(dist(theta_mat))
avg_dist  <- mean(dists[lower.tri(dists)])
cat(sprintf(
"t = %4d | tr = %4d | ESS/M = %.3f | mean #edges = %.3f ± %.3f | unique = %d\n | Euclidean dist = %.4f\n",
t, tr, ess_t / M, mean_edges, se_edges, n_unique, avg_dist))
edge_ct    <- rowSums(slab_w)
mean_edges <- w_mean(edge_ct, w_new)
se_edges   <- mc_se(edge_ct, w_new, ess_t)
key_vec   <- apply(cbind(slab_w, theta_mat), 1L,
\(row) paste(row, collapse = ","))
n_unique  <- length(unique(key_vec))
dists     <- as.matrix(dist(theta_mat))
avg_dist  <- mean(dists[lower.tri(dists)])
cat(sprintf(
"t = %4d | tr = %4d | ESS/M = %.3f | mean #edges = %.3f ± %.3f | unique = %d\n | Euclidean dist = %.4f\n",
t, tr, ess_t / M, mean_edges, se_edges, n_unique, avg_dist))
dists     <- as.matrix(dist(theta_mat))
avg_dist  <- mean(dists[lower.tri(dists)])
cat(sprintf(
"t = %4d | tr = %4d | ESS/M = %.3f | mean #edges = %.3f ± %.3f | unique = %d\n | Euclidean dist = %.4f\n",
t, tr, ess_t / M, mean_edges, se_edges, n_unique, avg_dist))
## 4. per-edge summaries ----------------------------------------------------
inc_prob <- colSums(slab_w  * w_new)
inc_prob
edge_summ <- lapply(seq_along(inc_prob), function(e) {
## MC-SE of inclusion probability
se_inc <- sqrt(inc_prob[e] * (1 - inc_prob[e]) / ess_t)
## conditional posterior of rho if edge present at all
gamma_e <- slab_w[, e]
rho_e   <- rho_mat[,  e]
w_cond  <- w_new * gamma_e
if (sum(w_cond) < 1e-12) {
cat(sprintf("  Edge %2d : P(dep)=%.3f ± %.3f | never present\n",
e, inc_prob[e], se_inc))
return(list(edge = e, p_dep = inc_prob[e], se_inc = se_inc,
mu_rho = NA, sd_rho = NA,
q025 = NA, q975 = NA, se_rho = NA))
}
w_cond <- w_cond / sum(w_cond)
mu_rho <- sum(w_cond * rho_e)
sd_rho <- sqrt( sum(w_cond * (rho_e - mu_rho)^2) )
qs     <- w_quantile(rho_e, w_cond, q_probs)
## MC-SE of the mean (zero-padded variance / ESS)
var_rho_zpad <- w_var(rho_e * slab_w[, e], w_new,
mu_rho * inc_prob[e])          # PATCH
se_rho       <- sqrt(var_rho_zpad / ess_t)
cat(sprintf(
"  Edge %2d : P(dep)=%.3f ± %.3f | ρ = %.3f (SD %.3f, MC-SE %.3f) | 95%% CI = [%.3f, %.3f]\n",
e, inc_prob[e], se_inc, mu_rho, sd_rho, se_rho, qs[1], qs[2]))
list(edge = e, p_dep = inc_prob[e], se_inc = se_inc,
mu_rho = mu_rho, sd_rho = sd_rho,
q025 = qs[1], q975 = qs[2], se_rho = se_rho)
})
# 4. diagnostics ────────────────────────────────────────────────────────
dg <- diagnostic_report(t_idx, tr, U, particles, w_new, cfg)
out$diag_log[pos, `:=`(
t      = t_idx,
tr     = tr,
ESS    = dg$ESS,
unique = dg$unique,
euc    = dg$euc
)]
pos <- pos + 1L
ESS(w_new)
cfg$ess_thr * M
pos <- 1L        #  row pointer for diag_log
# ── main SMC loop ──────────────────────────────────────────────────────────
for (t_idx in seq_len(N)) {
u_row <- U[t_idx, , drop = FALSE]
# 1. propagate step ──────────────────────────────────────────────────────
#particles <- propagate_particles(particles, cfg)
# 2. predictive metrics (after burn-in) ──────────────────────────────────
if (t_idx > cfg$W_predict) {
w_prev <- vapply(particles, `[[`, numeric(1), "w")
w_prev <- w_prev / sum(w_prev)
pm <- compute_predictive_metrics(u_row, particles,
skeleton, w_prev, cfg)
out$log_pred[t_idx]    <- pm$log_pred_density
out$theta_mean[t_idx,] <- pm$theta_mean
out$theta_se[t_idx,]   <- pm$theta_se
#out$gamma_mean[t_idx,] <- pm$gamma_mean
#out$gamma_se[t_idx,]   <- pm$gamma_se
}
# 3. weight update ──────────────────────────────────────────────────────
log_incr  <- compute_log_incr(particles, u_row, skeleton, cfg)
particles <- update_weights(particles, log_incr)
w_new     <- vapply(particles, `[[`, numeric(1), "w")
# 4. diagnostics ────────────────────────────────────────────────────────
dg <- diagnostic_report(t_idx, tr, U, particles, w_new, cfg)
out$diag_log[pos, `:=`(
t      = t_idx,
tr     = tr,
ESS    = dg$ESS,
unique = dg$unique,
euc    = dg$euc
)]
pos <- pos + 1L
# 5. resample + move if ESS below threshold ─────────────────────────────
if (ESS(w_new) < cfg$ess_thr * M && t_idx < N) { break
data_up_to_t <- U[max(1, t_idx - cfg$W + 1):t_idx, , drop = FALSE]
newAnc <- stratified_resample(w_new)
move_out     <- resample_move(particles, newAnc, data_up_to_t,
cl, type, cfg, skeleton=skeleton)
particles <- move_out$particles
out$mh_acc_pct[t_idx] <- move_out$acc_pct
} else {
step_prev <- t_idx - 1L
newAnc    <- if (step_prev < 1L) seq_len(M) else out$ancestorIndices[, step_prev]
}
out$ancestorIndices[, t_idx] <- newAnc
# 6. save history ───────────────────────────────────────────────────────
out$theta_hist[, t_idx, ] <- t(vapply(particles, `[[`, numeric(K), "theta"))
#out$gamma_hist[, t_idx, ] <- t(vapply(particles, `[[`, integer(K), "gamma"))
theta_mat <- do.call(rbind, lapply(particles, `[[`, "theta"))
out$incl_hist[t_idx, ] <-
colSums(responsibility(theta_mat, cfg) * w_new)
}
ESS(w_new)
cfg$ess_thr * M
data_up_to_t <- U[max(1, t_idx - cfg$W + 1):t_idx, , drop = FALSE]
data_up_to_t
newAnc <- stratified_resample(w_new)
newAncestors
newAnc <- stratified_resample(w_new)
newAncestors <- newAnc
#idx       <- sample.int(M, M, TRUE, prob = w_new)
particles <- particles[newAncestors]                  # cópia simples
for (p in particles) {                       # reinicia pesos
p$w <- 1 / cfg$M
}
mh_n_prop <- cfg$M * cfg$n_mh
mh_n_acc  <- 0
clusterSetRNGStream(cl, 42)
p <- particles
prop <- p
p$theta
p
p <- particles[[1]]
p
prop <- p
p$theta
rnorm(cfg$K, 0, cfg$step_sd)
prop$theta <- p$theta + rnorm(cfg$K, 0, cfg$step_sd)
vine_prop <- vine_from_particle(prop, skeleton, cfg)
vine_curr <- vine_from_particle(p,    skeleton, cfg)
vine_prop
vine_curr
ll_prop <- sum(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps)))
ll_curr <- sum(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps)))
ll_prop
ll_curr
log_acc <- (ll_prop + log_prior(prop$theta, cfg)) -
(ll_curr + log_prior(p$theta, cfg))
log_acc
ll_prop
ll_curr
log_prior(prop$theta, cfg))
log_prior(prop$theta, cfg)
log_prior(p$theta, cfg)
dnorm(theta, 0, cfg$slab_sd)
dnorm(0, 0, cfg$slab_sd)
dnorm(0.1, 0, cfg$slab_sd)
dnorm(0.5, 0, cfg$slab_sd)
library(here)
source(here::here("src","config.R"))
res_stand <- readRDS("simul_results/static_dgp/standard_3_pi05_nmh1_N250_KM")
# plot(results$diag_log$unique, type="l")
#
plot_genealogy_theta(res_stand$theta_hist, res_stand$ancestorIndices, edge_id = 1)
plot(results$diag_log$unique, type="l")
plot(res_stand$diag_log$unique, type="l")
res_SS <- readRDS("simul_results/static_dgp/standard_3_pi05_nmh1_N250_SSVS")
plot(res_SS$diag_log$unique, type="l")
#
plot_genealogy_theta(res_SS$theta_hist, res_SS$ancestorIndices, edge_id = 1)
plot(res_SS$diag_log$ESS, type="l")
plot(res_stand$diag_log$ESS, type="l")
sum(res_stand$diag_log$ESS<500)
sum(res_SS$diag_log$ESS<500)
res_SS$particles_final
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/runner.R", echo=TRUE)
