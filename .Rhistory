# available CoVaR labels in the 3rd dim:
labs_avail <- if (!is.null(dimnames(CoVaR)[[3]])) dimnames(CoVaR)[[3]] else NULL
dt_covar <- rbindlist(lapply(seq_len(nrow(grid)), function(i) {
a <- grid$alpha_j[i]
b <- grid$alpha_port[i]
k <- .which_alpha(alphas_out, a)
# simple label (and a robust fallback if names are like "a0.10b0.10")
lab_simple <- paste0("a", a, "b", b)
lab <- lab_simple
if (!is.null(labs_avail) && !(lab_simple %in% labs_avail)) {
lab_alt <- paste0("a", formatC(a, format = "f", digits = 2),
"b", formatC(b, format = "f", digits = 2))
if (lab_alt %in% labs_avail) lab <- lab_alt
# else: keep lab_simple; will error clearly if not found
}
VaRj  <- matrix(riskVaR[, , k], ncol = d); colnames(VaRj) <- tickers
CoVab <- CoVaR[, , lab, drop = FALSE][, , 1]; colnames(CoVab) <- tickers
cond <- covar_hits_by_j(rp, as.data.table(Y), VaRj, CoVab)
rbindlist(lapply(seq_len(d), function(j) {
hj <- cond$hits[[j]]
if (length(hj) == 0) {
data.table(asset = tickers[j], alpha_j = a, alpha_port = b,
T_event = 0L, rate = NA_real_, kupiec = NA_real_, ind = NA_real_, cc = NA_real_)
} else {
data.table(asset = tickers[j], alpha_j = a, alpha_port = b,
T_event = length(hj), rate = mean(hj),
kupiec = kupiec_test(hj, b)$pval,
ind    = christoffersen_ind_test(hj)$pval,
cc     = christoffersen_cc_test(hj, b)$pval)
}
}))
}))
list(port_var = dt_port[], asset_var = dt_asset[], covar = dt_covar[])
}
# ---- multi-model wrapper ------------------------------------------------------
compare_models <- function(out_list_named,
data,
date_from = as.Date("2003-01-01"),
date_to   = as.Date("2100-01-01"),
assets    = NULL,
alphas_var   = c(0.10, 0.05, 0.025, 0.01),
alphas_covar = c(0.10, 0.05)) {
stopifnot(!is.null(names(out_list_named)), all(nzchar(names(out_list_named))))
res <- lapply(names(out_list_named), function(m) {
out <- out_list_named[[m]]
ans <- evaluate_model(out, data, date_from, date_to, assets, alphas_var, alphas_covar)
list(
port_var  = cbind(model = m, ans$port_var),
asset_var = cbind(model = m, ans$asset_var),
covar     = cbind(model = m, ans$covar)
)
})
list(
port_var  = rbindlist(lapply(res, `[[`, "port_var"),  use.names = TRUE, fill = TRUE),
asset_var = rbindlist(lapply(res, `[[`, "asset_var"), use.names = TRUE, fill = TRUE),
covar     = rbindlist(lapply(res, `[[`, "covar"),     use.names = TRUE, fill = TRUE)
)
}
# ---- example usage ------------------------------------------------------------
# Load data once
data <- import_data(drop_first_col = FALSE, n_assets = 3)
# Load as many 'out' objects as you want and name them for comparison
out_list <- list(
baseline   = readRDS("C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/empirical_results/test.rds"),
alt1   = readRDS("C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/empirical_results/out_naive_2_extend_t.rds")
# , alt2   = readRDS(".../empirical_results/standard_tip.rds")
)
# Choose period & assets by name (Date handling is centralized and consistent)
date_from <- as.Date("2003-01-01")
date_to   <- as.Date("2025-01-01")
assets_sel <- NULL            # or c("AIG","AXP","BAC") to force a set/order
# 1) Build conditional evaluation samples
ev_base <- covar_eval_sample(out_list$baseline, data, j = j, a = a, b = b,
date_from = date_from, date_to = date_to)
# ===== Helper: build conditional CoVaR hit time series (base-R friendly) =====
covar_hits_timeseries <- function(out, data, j, a = 0.10, b = 0.10,
date_from = as.Date("2005-01-01"),
date_to   = as.Date("2100-01-01"),
assets    = NULL) {
al <- align_and_filter(out, data, date_from, date_to, keep_cols = assets)
Y        <- al$Y_keep
keep_idx <- al$keep_idx
dates    <- al$dates_oos[keep_idx]
d        <- ncol(Y); tickers <- colnames(Y)
if (j < 1L || j > d) stop("j out of bounds")
rp <- rowMeans(Y)
alphas_out <- if (!is.null(out$cfg$alphas)) as.numeric(out$cfg$alphas) else stop("cfg$alphas missing")
k   <- .which_alpha(alphas_out, a)
lab <- paste0("a", a, "b", b)
# subset model arrays by SAME date indices
riskVaR <- out$risk$VaR[keep_idx, , , drop = FALSE]
CoVaR   <- out$CoVaR_tail[keep_idx, , , drop = FALSE]
# optional: align asset order to data
if (!is.null(dimnames(riskVaR)[[2]])) {
pos <- match(tickers, dimnames(riskVaR)[[2]])
if (anyNA(pos)) stop("Tickers not found in riskVaR dimnames.")
riskVaR <- riskVaR[, pos, , drop = FALSE]
if (!is.null(dimnames(CoVaR)[[2]])) CoVaR <- CoVaR[, pos, , drop = FALSE]
}
VaRj  <- matrix(riskVaR[, , k], ncol = d); colnames(VaRj) <- tickers
labs_avail <- dimnames(CoVaR)[[3]]
if (!is.null(labs_avail) && !(lab %in% labs_avail)) {
lab_alt <- paste0("a", formatC(a, format = "f", digits = 2),
"b", formatC(b, format = "f", digits = 2))
if (lab_alt %in% labs_avail) lab <- lab_alt
}
CoVab <- CoVaR[, , lab, drop = FALSE][, , 1]; colnames(CoVab) <- tickers
# conditioning mask & hits (NA on non-event days)
mask_j <- Y[, j] <= VaRj[, j]
hits_j <- rep(NA_real_, length(dates))
if (any(mask_j)) hits_j[mask_j] <- as.numeric(rp[mask_j] <= CoVab[mask_j, j])
# cumulative stats along observed events only
idx_obs    <- which(mask_j)
cum_hits   <- rep(NA_real_, length(dates))
cum_trials <- rep(NA_real_, length(dates))
if (length(idx_obs)) {
cum_hits[idx_obs]   <- cumsum(hits_j[idx_obs])
cum_trials[idx_obs] <- seq_along(idx_obs)
}
cum_prop <- ifelse(is.na(cum_hits) | is.na(cum_trials), NA_real_, cum_hits / cum_trials)
list(
Date      = dates,
asset_j   = tickers[j],
event     = mask_j,      # TRUE on conditioning-event days
hit       = hits_j,      # 1/0 on event days; NA else
cum_hits  = cum_hits,    # cumulative hits on observed timeline
cum_trials= cum_trials,  # cumulative events count
cum_prop  = cum_prop     # cumulative proportion among observed
)
}
# --------- build conditional CoVaR evaluation sample ----------
# Returns dates, mask of conditioning events, portfolio y, CoVaR threshold q
covar_eval_sample <- function(out, data, j, a = 0.10, b = 0.10,
date_from = as.Date("2005-01-01"),
date_to   = as.Date("2100-01-01"),
assets    = NULL) {
al <- align_and_filter(out, data, date_from, date_to, keep_cols = assets)
Y        <- al$Y_keep
keep_idx <- al$keep_idx
dates    <- al$dates_oos[keep_idx]
d        <- ncol(Y)
tickers  <- colnames(Y)
if (j < 1L || j > d) stop("j out of bounds")
rp <- rowMeans(Y)
alphas_out <- if (!is.null(out$cfg$alphas)) as.numeric(out$cfg$alphas) else stop("cfg$alphas missing")
k   <- .which_alpha(alphas_out, a)
lab <- paste0("a", a, "b", b)
riskVaR <- out$risk$VaR[keep_idx, , , drop = FALSE]
CoVaR   <- out$CoVaR_tail[keep_idx, , , drop = FALSE]
# align asset order if dimnames exist
if (!is.null(dimnames(riskVaR)[[2]])) {
pos <- match(tickers, dimnames(riskVaR)[[2]])
if (anyNA(pos)) stop("Tickers not found in riskVaR dimnames.")
riskVaR <- riskVaR[, pos, , drop = FALSE]
if (!is.null(dimnames(CoVaR)[[2]])) CoVaR <- CoVaR[, pos, , drop = FALSE]
}
# fallback for labels like "a0.10b0.10"
labs_avail <- dimnames(CoVaR)[[3]]
if (!is.null(labs_avail) && !(lab %in% labs_avail)) {
lab_alt <- paste0("a", formatC(a, format = "f", digits = 2),
"b", formatC(b, format = "f", digits = 2))
if (lab_alt %in% labs_avail) lab <- lab_alt
}
VaRj  <- matrix(riskVaR[, , k], ncol = d); colnames(VaRj) <- tickers
CoVab <- CoVaR[, , lab, drop = FALSE][, , 1]; colnames(CoVab) <- tickers
mask <- Y[, j] <= VaRj[, j]       # conditioning events (asset j at level a)
q    <- CoVab[, j]                # CoVaR threshold for portfolio
y    <- rp                        # realized portfolio return
list(dates = dates, mask = mask, y = y, q = q,
asset_j = tickers[j], alpha_j = a, alpha_p = b)
}
# 1) Build conditional evaluation samples
ev_base <- covar_eval_sample(out_list$baseline, data, j = j, a = a, b = b,
date_from = date_from, date_to = date_to)
# 1) Build conditional evaluation samples
ev_base <- covar_eval_sample(out_list$baseline, data, j=2, a=0.10, b=0.10,
date_from = date_from, date_to = date_to)
ev_alt  <- covar_eval_sample(out_list$alt1,     data, j=2, a=0.10, b=0.10,
date_from = date_from, date_to = date_to)
# 2) Hits on each model's own conditioning days (NA elsewhere)
hits_base_loc <- rep(NA_real_, length(ev_base$dates))
hits_base_loc[ev_base$mask] <- as.numeric(ev_base$y[ev_base$mask] <= ev_base$q[ev_base$mask])
hits_alt_loc <- rep(NA_real_, length(ev_alt$dates))
hits_alt_loc[ev_alt$mask] <- as.numeric(ev_alt$y[ev_alt$mask] <= ev_alt$q[ev_alt$mask])
# 3) Align ALT to BASE date grid
alt_on_base <- rep(NA_real_, length(ev_base$dates))
m <- match(ev_base$dates, ev_alt$dates)
alt_on_base[!is.na(m)] <- hits_alt_loc[m[!is.na(m)]]
# 4) Indices (within BASE filtered window) where baseline hit & alt did not
idx_local <- which(hits_base_loc == 1 & (is.na(alt_on_base) | alt_on_base == 0))
# 5) Map those to your global plotting axis (data$U$date)
pos_global <- match(ev_base$dates, data$U$date)
mark_idx   <- na.omit(pos_global[idx_local])   # <- indices into data$U$date
op <- par(no.readonly = TRUE)
par(mfrow = c(3,1), mar = c(4,4,2,1))
time_index <- data$U$date
cols <- 1:length(labels_all)
for (e in 1:n_edges) {
mat <- prop_list[[e]]
plot(time_index, mat[,1], type = "l", ylim = c(0,1),
xlab = "Time", ylab = "Proportion",
main = paste("Edge", e),
col = cols[1], lwd = 2)
if (ncol(mat) > 1) {
for (jlab in 2:ncol(mat)) {
lines(time_index, mat[, jlab], col = cols[jlab], lwd = 2)
}
}
## >>> ADD THIS SINGLE LINE <<<
if (length(mark_idx)) abline(v = time_index[mark_idx], col = "red", lty = 3)
legend("topright", legend = colnames(mat), col = cols, lwd = 2, bty = "n")
}
# All labels present in the array
labels_all <- sort(unique(as.vector(fh)))
data$U$date
# fam_hist: array [particles x time x edges]
fh <- out$fam_hist
out = out_list$baseline
# fam_hist: array [particles x time x edges]
fh <- out$fam_hist
dim(fh)
n_edges <- dim(fh)[3]
n_time  <- dim(fh)[2]
# All labels present in the array
labels_all <- sort(unique(as.vector(fh)))
n_edges
op <- par(no.readonly = TRUE)
par(mfrow = c(3,1), mar = c(4,4,2,1))
time_index <- data$U$date
cols <- 1:length(labels_all)
for (e in 1:n_edges) {
mat <- prop_list[[e]]
plot(time_index, mat[,1], type = "l", ylim = c(0,1),
xlab = "Time", ylab = "Proportion",
main = paste("Edge", e),
col = cols[1], lwd = 2)
if (ncol(mat) > 1) {
for (jlab in 2:ncol(mat)) {
lines(time_index, mat[, jlab], col = cols[jlab], lwd = 2)
}
}
## >>> ADD THIS SINGLE LINE <<<
if (length(mark_idx)) abline(v = time_index[mark_idx], col = "red", lty = 3)
legend("topright", legend = colnames(mat), col = cols, lwd = 2, bty = "n")
}
# ---- compute proportions -----------------------------------------------------
# result: list of length n_edges, each element is matrix [time x labels]
prop_list <- vector("list", n_edges)
for (e in 1:n_edges) {
mat <- prop_list[[e]]
plot(time_index, mat[,1], type = "l", ylim = c(0,1),
xlab = "Time", ylab = "Proportion",
main = paste("Edge", e),
col = cols[1], lwd = 2)
if (ncol(mat) > 1) {
for (jlab in 2:ncol(mat)) {
lines(time_index, mat[, jlab], col = cols[jlab], lwd = 2)
}
}
## >>> ADD THIS SINGLE LINE <<<
if (length(mark_idx)) abline(v = time_index[mark_idx], col = "red", lty = 3)
legend("topright", legend = colnames(mat), col = cols, lwd = 2, bty = "n")
}
par(op)
# 1) Build conditional evaluation samples
ev_base <- covar_eval_sample(out_list$baseline, data, j=2, a=0.10, b=0.10,
date_from = date_from, date_to = date_to)
ev_alt  <- covar_eval_sample(out_list$alt1,     data, j=2, a=0.10, b=0.10,
date_from = date_from, date_to = date_to)
# 2) Hits on each model's own conditioning days (NA elsewhere)
hits_base_loc <- rep(NA_real_, length(ev_base$dates))
hits_base_loc[ev_base$mask] <- as.numeric(ev_base$y[ev_base$mask] <= ev_base$q[ev_base$mask])
hits_alt_loc <- rep(NA_real_, length(ev_alt$dates))
hits_alt_loc[ev_alt$mask] <- as.numeric(ev_alt$y[ev_alt$mask] <= ev_alt$q[ev_alt$mask])
# 3) Align ALT to BASE date grid
alt_on_base <- rep(NA_real_, length(ev_base$dates))
m <- match(ev_base$dates, ev_alt$dates)
alt_on_base[!is.na(m)] <- hits_alt_loc[m[!is.na(m)]]
# 4) Indices (within BASE filtered window) where baseline hit & alt did not
idx_local <- which(hits_base_loc == 1 & (is.na(alt_on_base) | alt_on_base == 0))
# 5) Map those to your global plotting axis (data$U$date)
pos_global <- match(ev_base$dates, data$U$date)
mark_idx   <- na.omit(pos_global[idx_local])   # <- indices into data$U$date
## ============================================================================
op <- par(no.readonly = TRUE)
par(mfrow = c(3,1), mar = c(4,4,2,1))
time_index <- data$U$date
cols <- 1:length(labels_all)
for (e in 1:n_edges) {
mat <- prop_list[[e]]
plot(time_index, mat[,1], type = "l", ylim = c(0,1),
xlab = "Time", ylab = "Proportion",
main = paste("Edge", e),
col = cols[1], lwd = 2)
if (ncol(mat) > 1) {
for (jlab in 2:ncol(mat)) {
lines(time_index, mat[, jlab], col = cols[jlab], lwd = 2)
}
}
## >>> ADD THIS SINGLE LINE <<<
if (length(mark_idx)) abline(v = time_index[mark_idx], col = "red", lty = 3)
legend("topright", legend = colnames(mat), col = cols, lwd = 2, bty = "n")
}
ev_base
ev_alt
# 2) Hits on each model's own conditioning days (NA elsewhere)
hits_base_loc <- rep(NA_real_, length(ev_base$dates))
hits_base_loc[ev_base$mask] <- as.numeric(ev_base$y[ev_base$mask] <= ev_base$q[ev_base$mask])
hits_alt_loc <- rep(NA_real_, length(ev_alt$dates))
hits_alt_loc[ev_alt$mask] <- as.numeric(ev_alt$y[ev_alt$mask] <= ev_alt$q[ev_alt$mask])
hits_base_loc
hits_base_loc[ev_base$mask] <- as.numeric(ev_base$y[ev_base$mask] <= ev_base$q[ev_base$mask])
hits_base_loc
hits_alt_loc <- rep(NA_real_, length(ev_alt$dates))
hits_alt_loc[ev_alt$mask] <- as.numeric(ev_alt$y[ev_alt$mask] <= ev_alt$q[ev_alt$mask])
# 3) Align ALT to BASE date grid
alt_on_base <- rep(NA_real_, length(ev_base$dates))
m <- match(ev_base$dates, ev_alt$dates)
alt_on_base[!is.na(m)] <- hits_alt_loc[m[!is.na(m)]]
# 4) Indices (within BASE filtered window) where baseline hit & alt did not
idx_local <- which(hits_base_loc == 1 & (is.na(alt_on_base) | alt_on_base == 0))
# 5) Map those to your global plotting axis (data$U$date)
pos_global <- match(ev_base$dates, data$U$date)
mark_idx   <- na.omit(pos_global[idx_local])   # <- indices into data$U$date
mark_idx
op <- par(no.readonly = TRUE)
par(mfrow = c(3,1), mar = c(4,4,2,1))
time_index <- data$U$date
cols <- 1:length(labels_all)
for (e in 1:n_edges) {
mat <- prop_list[[e]]
plot(time_index, mat[,1], type = "l", ylim = c(0,1),
xlab = "Time", ylab = "Proportion",
main = paste("Edge", e),
col = cols[1], lwd = 2)
if (ncol(mat) > 1) {
for (jlab in 2:ncol(mat)) {
lines(time_index, mat[, jlab], col = cols[jlab], lwd = 2)
}
}
## >>> ADD THIS SINGLE LINE <<<
if (length(mark_idx)) abline(v = time_index[mark_idx], col = "red", lty = 3)
legend("topright", legend = colnames(mat), col = cols, lwd = 2, bty = "n")
}
# ============================ SETUP ===========================================
library(data.table)
library(here)
# Your config must define import_data()
source(here("src/R", "config.R"))
# ---------- minimal helpers we need ----------
.which_alpha <- function(alphas, a) {
i <- which.min(abs(alphas - a))
if (!length(i) || !is.finite(i)) stop("Cannot match alpha.")
i
}
# Align data$y_real to model OOS arrays and build date filter indices
align_and_filter <- function(out, data,
date_from = as.Date("1900-01-01"),
date_to   = as.Date("2100-01-01"),
keep_cols = NULL) {
stopifnot("y_real" %in% names(data))
y_dt <- as.data.table(data$y_real)
if (!"Date" %in% names(y_dt)) stop("data$y_real must have a Date column.")
setkey(y_dt, Date)
n_oos <- nrow(out$port$VaR)
if (!is.finite(n_oos) || n_oos <= 0) stop("out$port$VaR must be n_oos x K.")
y_oos <- y_dt[(.N - n_oos + 1L):.N]         # exact OOS block used by the model
if (!is.null(keep_cols)) {
cols <- c("Date", keep_cols)
missing <- setdiff(cols, names(y_oos))
if (length(missing)) stop("Missing columns in y_real: ", paste(missing, collapse = ", "))
y_oos <- y_oos[, ..cols]
}
keep_idx <- which(y_oos$Date >= date_from & y_oos$Date <= date_to)
tickers <- setdiff(colnames(y_oos), "Date")
Y_full  <- as.matrix(y_oos[, ..tickers])
list(
dates_oos = y_oos$Date,
keep_idx  = keep_idx,
Y_keep    = Y_full[keep_idx, , drop = FALSE],
tickers   = tickers
)
}
# Build the conditional CoVaR evaluation sample for (j,a,b)
covar_eval_sample <- function(out, data, j, a = 0.10, b = 0.10,
date_from = as.Date("2005-01-01"),
date_to   = as.Date("2100-01-01"),
assets    = NULL) {
al <- align_and_filter(out, data, date_from, date_to, keep_cols = assets)
Y        <- al$Y_keep
keep_idx <- al$keep_idx
dates    <- al$dates_oos[keep_idx]
d        <- ncol(Y)
tickers  <- colnames(Y)
if (j < 1L || j > d) stop("j out of bounds")
rp <- rowMeans(Y)
alphas_out <- if (!is.null(out$cfg$alphas)) as.numeric(out$cfg$alphas) else stop("cfg$alphas missing")
k   <- .which_alpha(alphas_out, a)
lab <- paste0("a", a, "b", b)
riskVaR <- out$risk$VaR[keep_idx, , , drop = FALSE]
CoVaR   <- out$CoVaR_tail[keep_idx, , , drop = FALSE]
# align asset order if dimnames exist
if (!is.null(dimnames(riskVaR)[[2]])) {
pos <- match(tickers, dimnames(riskVaR)[[2]])
if (anyNA(pos)) stop("Tickers not found in riskVaR dimnames.")
riskVaR <- riskVaR[, pos, , drop = FALSE]
if (!is.null(dimnames(CoVaR)[[2]])) CoVaR <- CoVaR[, pos, , drop = FALSE]
}
# fallback for labels like "a0.10b0.10"
labs_avail <- dimnames(CoVaR)[[3]]
if (!is.null(labs_avail) && !(lab %in% labs_avail)) {
lab_alt <- paste0("a", formatC(a, format = "f", digits = 2),
"b", formatC(b, format = "f", digits = 2))
if (lab_alt %in% labs_avail) lab <- lab_alt
}
VaRj  <- matrix(riskVaR[, , k], ncol = d); colnames(VaRj) <- tickers
CoVab <- CoVaR[, , lab, drop = FALSE][, , 1]; colnames(CoVab) <- tickers
mask <- Y[, j] <= VaRj[, j]     # conditioning events
q    <- CoVab[, j]              # CoVaR threshold for portfolio
y    <- rp                      # realized portfolio return
list(dates = dates, mask = mask, y = y, q = q,
asset_j = tickers[j], alpha_j = a, alpha_p = b)
}
# ============================ LOAD DATA/MODELS ================================
data <- import_data(drop_first_col = FALSE, n_assets = 3)
out_list <- list(
baseline = readRDS("C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/empirical_results/test.rds"),
alt1     = readRDS("C:/Users/55419/Documents/Research/project_1/Code/Exploratory/smc_vines/empirical_results/out_naive_2_extend_t.rds")
)
# Choose (j, a, b) and time window
j <- 2
a <- 0.10
b <- 0.10
date_from <- as.Date("2007-01-01")
date_to   <- as.Date("2025-01-01")
# ============================ COMPUTE HITS & MARKS ============================
# Build conditional evaluation samples for both models
ev_base <- covar_eval_sample(out_list$baseline, data, j = j, a = a, b = b,
date_from = date_from, date_to = date_to)
ev_alt  <- covar_eval_sample(out_list$alt1,     data, j = j, a = a, b = b,
date_from = date_from, date_to = date_to)
# Hits on each model's own conditioning days (NA elsewhere)
hits_base_loc <- rep(NA_real_, length(ev_base$dates))
hits_base_loc[ev_base$mask] <- as.numeric(ev_base$y[ev_base$mask] <= ev_base$q[ev_base$mask])
hits_alt_loc <- rep(NA_real_, length(ev_alt$dates))
hits_alt_loc[ev_alt$mask] <- as.numeric(ev_alt$y[ev_alt$mask] <= ev_alt$q[ev_alt$mask])
# Align ALT hits to BASE date grid
alt_on_base <- rep(NA_real_, length(ev_base$dates))
m <- match(ev_base$dates, ev_alt$dates)
alt_on_base[!is.na(m)] <- hits_alt_loc[m[!is.na(m)]]
# Local indices (within BASE filtered window) where baseline==1 & alt==0
idx_local <- which(hits_base_loc == 1 & (is.na(alt_on_base) | alt_on_base == 0))
# Map to your global plotting axis; prefer data$U$date if available
full_time <- if ("U" %in% names(data) && "date" %in% names(data$U)) data$U$date else NULL
if (is.null(full_time)) {
warning("data$U$date not found; using ev_base$dates for x-axis.")
full_time <- ev_base$dates
}
pos_global <- match(ev_base$dates, full_time)
mark_idx   <- na.omit(pos_global[idx_local])              # indices into full_time
mark_idx   <- mark_idx[mark_idx >= 1 & mark_idx <= length(full_time)]
# ============================ FAMILY PROPORTIONS ==============================
# Use baseline model's fam_hist (shape: [particles x time x edges])
fh <- out_list$baseline$fam_hist
stopifnot(length(dim(fh)) == 3)
n_particles <- dim(fh)[1]
n_time      <- dim(fh)[2]
n_edges     <- dim(fh)[3]
# Ensure full_time matches n_time if it came from data$U$date
if (length(full_time) != n_time) {
warning("Length of x-axis (full_time) != n_time in fam_hist. Falling back to 1:n_time.")
full_time <- seq_len(n_time)
}
labels_all <- sort(unique(as.vector(fh)))
if (!length(labels_all)) stop("No labels found in fam_hist.")
# compute proportions: list of 3 matrices [time x n_labels]
prop_list <- vector("list", n_edges)
for (e in seq_len(n_edges)) {
slice <- fh[, , e]                              # [particles x time]
mat <- matrix(NA_real_, nrow = n_time, ncol = length(labels_all))
colnames(mat) <- as.character(labels_all)
for (t in seq_len(n_time)) {
counts <- table(factor(slice[, t], levels = labels_all))
mat[t, ] <- as.numeric(counts) / sum(counts)
}
prop_list[[e]] <- mat
}
names(prop_list) <- paste0("edge", seq_len(n_edges))
stopifnot(!any(sapply(prop_list, is.null)))
# ============================ PLOTS WITH MARKERS ==============================
op <- par(no.readonly = TRUE)
on.exit(par(op), add = TRUE)
par(mfrow = c(n_edges, 1), mar = c(4,4,2,1), xaxs = "i")
cols <- seq_len(ncol(prop_list[[1]]))  # simple colors per label
for (e in seq_len(n_edges)) {
mat <- prop_list[[e]]
if (!is.matrix(mat)) stop("prop_list[[", e, "]] is not a matrix.")
# draw first series
plot(full_time, mat[, 1], type = "l", ylim = c(0, 1),
xlab = "Time", ylab = "Proportion",
main = paste("Edge", e),
col = cols[1], lwd = 2)
# additional series
if (!is.null(ncol(mat)) && ncol(mat) > 1) {
for (jlab in 2:ncol(mat)) {
lines(full_time, mat[, jlab], col = cols[jlab], lwd = 2)
}
}
legend("topright", legend = colnames(mat), col = cols, lwd = 2, bty = "n", title = "Family")
# <<< vertical lines where baseline==1 & alt==0 >>>
if (length(mark_idx)) abline(v = full_time[mark_idx], col = "red", lty = 3)
}
