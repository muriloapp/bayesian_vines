## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
log_acc
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
i=2
p <- particles_local[[i]]
local_acc <- 0L
k
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
aux <- log(runif(1))
log_acc
aux
i=3
p <- particles_local[[i]]
local_acc <- 0L
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
### Add conditional such that if any entri is nan do not accept
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
print(log_acc)
aux <- log(runif(1))
if (aux < log_acc) {
prop$last_accept <- TRUE
return(prop)
} else {
p$last_accept <- FALSE
return(p)
}
}
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
mh_step <- function(p, data_up_to_t, skeleton, cfg) {
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
### Add conditional such that if any entri is nan do not accept
## proposal symmetric by construction
log_acc <- (ll_prop + log_prior(prop, cfg)) -
(ll_curr + log_prior(p,    cfg))
print(log_acc)
print(ll_prop)
print(log_prior(prop, cfg))
print(ll_curr)
print(log_prior(p,    cfg))
aux <- log(runif(1))
if (aux < log_acc) {
prop$last_accept <- TRUE
return(prop)
} else {
p$last_accept <- FALSE
return(p)
}
}
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
p <- mh_step(p, data_up_to_t, skeleton, cfg)
K <- cfg$K
fam_tbl <- active_fams(cfg)            # data.frame(name, code, npar)
codes   <- fam_tbl$code
prop <- p
#skeleton$structure
# family flips with probability q_flip per edge
flip_mask <- runif(K) < cfg$q_flip
if (any(flip_mask)) {
idxs <- which(flip_mask)
for (idx in idxs) {
old_code <- prop$fam[idx]
tr_idx <- cfg$edge_tree[idx] # map edge tree position
allowed_names <- if (tr_idx == 1) # check allowed families in each tree
cfg$families_first else cfg$families_deep
allowed_codes <- FAM_INFO$code[FAM_INFO$name %in% allowed_names]
# choose a different family within the allowed set
new_code <- sample(allowed_codes[allowed_codes != old_code], 1L)
prop$fam[idx] <- new_code
if (tr_idx == 1) {         # Tree 1 → use MLE instead of wide prior
local_idx <- sum(cfg$edge_tree[seq_len(idx)] == 1)  # 1-based
pair <- cfg$edge_pair[local_idx, ]     # local_idx as before
uv   <- data_up_to_t[, pair]
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0;  prop$th2[idx] <- 0
} else {
fam_name <- FAM_INFO$name[FAM_INFO$code == new_code]
fit      <- bicop(data = uv,
family_set = fam_name,
keep_data  = FALSE)  # MLE by default
pars <- fit$parameters
prop$th1[idx] <- pars[1]
prop$th2[idx] <- if (length(pars) > 1) pars[2] else 0
}
} else {
## draw parameters from that family's PRIOR
if (new_code == FAM_INDEP) {
prop$th1[idx] <- 0; prop$th2[idx] <- 0
} else if (new_code == FAM_GAUSS) {
prop$th1[idx] <- runif(1, -0.99, 0.99)
prop$th2[idx] <- 0
} else if (new_code == FAM_BB1) {
lambdaU <- rbeta(1, 2, 2)
lambdaL <- rbeta(1, 2, 2)
tp      <- bb1_tail2par(lambdaL, lambdaU)
prop$th1[idx] <- tp[1]      # θ
prop$th2[idx] <- tp[2]      # δ
}
}
}
}
## (b) Random-walk on parameters of *current* families
## Gaussian  — truncated normal on ρ
ga_idx <- which(prop$fam == FAM_GAUSS)
if (length(ga_idx))
prop$th1[ga_idx] <- rtnorm_vec(prop$th1[ga_idx], cfg$step_sd,
-0.99, 0.99)
## BB1 — RW on (λL, λU) then map back
bb_idx <- which(prop$fam == FAM_BB1)
if (length(bb_idx)) {
lam <- t(mapply(bb1_par2tail,
prop$th1[bb_idx], prop$th2[bb_idx]))
lam[,1] <- rtnorm_vec(lam[,1], cfg$step_sd, 1e-3, 0.99)   # λL
lam[,2] <- rtnorm_vec(lam[,2], cfg$step_sd, 1e-3, 0.99)   # λU
par <- t(apply(lam, 1, \(x) bb1_tail2par(x[1], x[2])))
par <- t(apply(par, 1, \(x) sanitize_bb1(x[1], x[2])))
prop$th1[bb_idx] <- par[,1]    # θ
prop$th2[bb_idx] <- par[,2]    # δ
}
vine_prop <- fast_vine_from_particle(prop, skeleton)
vine_curr <- fast_vine_from_particle(p,    skeleton)
ll_prop <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_prop),
.Machine$double.eps))))
ll_curr <- sum(fillna_neg(log(pmax(dvinecop(data_up_to_t, vine_curr),
.Machine$double.eps))))
### Add conditional such that if any entri is nan do not accept
log_prior(prop, cfg)
prop = p
p=prop
lam <- bb1_par2tail(th1, th2)
fam = p$fam
th1 = p$th1
th2 = p$th2
lam <- bb1_par2tail(th1, th2)
lp_tail <- dbeta(lam[1], 2, 2, log=TRUE) +
dbeta(lam[2], 2, 2, log=TRUE)
lp <- lp_tail + bb1_log_jacobian(lam[1], lam[2]) - 2*cfg$lambda
lp
lp_tail
bb1_log_jacobian(lam[1], lam[2]) - 2*cfg$lambda
2*cfg$lambda
bb1_log_jacobian(lam[1], lam[2])
fillna_neg(lp)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/scripts/run_empirical.R", echo=TRUE)
library(sn)
renv::status()
renv::snapshot(type = "all")
renv::status()
renv::snapshot(type = "all")   # safest catch-all
renv::status()
miss <- subset(st$inconsistent, recorded == "n")$package
st  <- renv::status()          # invisible list with a data.frame of issues
miss <- subset(st$inconsistent, recorded == "n")$package
source("~/Research/project_1/Code/Exploratory/smc_vines/src/scripts/run_empirical.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/scripts/run_empirical.R", echo=TRUE)
source("~/Research/project_1/Code/Exploratory/smc_vines/src/scripts/run_empirical.R", echo=TRUE)
seq_len(N)
U      <- data$U
library(here)
source(here("src/R", "config.R"))
dat <- list(
U      = readRDS("data/PIT.rds")[,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[,2:4],#[,-1]
shape_fc = readRDS("data/shape_fc.rds")[,2:4]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
U      <- data$U
mu_fc  <- data$mu_fc
sig_fc <- data$sig_fc
df_fc     <- data$df_fc
shape_fc     <- data$shape_fc
t_train <- cfg$W_predict
skeleton <- make_skeleton_CVM(U[1:t_train, ])
cfg <- add_first_tree_map(cfg, skeleton)
exports <- c(
# constants & templates
"FAM_INFO", "FAM_INDEP", "FAM_GAUSS", "FAM_BB1",
"T_INDEP",  "T_GAUSS",   "T_BB1",
# helper functions
"active_fams", "sanitize_bb1", "mh_worker_standard", "mh_worker_block",
# core SMC kernels
"mh_step", "mh_step_in_tree",
"update_weights", "ESS", "systematic_resample", "resample_move",
# log-target & proposals
"log_prior", "bb1_tail2par", "bb1_par2tail", "bb1_log_jacobian",
"rtnorm_vec", "log_prior_edge",
# likelihood helpers
"bicop_dist", "vinecop_dist", "dvinecop", "fast_vine_from_particle",
"rvinecop","bicop",
# shared data objects
"skeleton", "cfg",
# diagnostics & prediction
"diagnostic_report", "compute_predictive_metrics",
"compute_log_incr",
# small utilities
"w_mean", "w_var", "mc_se", "w_quantile", "fillna_neg"
)
cl <- make_cluster(cfg$nc, cfg$seed, exports)
M <- cfg$M; K <- cfg$K; N <- nrow(U); d <- cfg$d; n_oos <- N - cfg$W_predict
tickers    <- colnames(U); A <- length(cfg$alphas)
out <- list(
log_pred    = numeric(n_oos),
diag_log    = data.table(t = integer(N), ESS = numeric(N),
unique = integer(N), euc = numeric(N),
sparsity = numeric(N)),
mh_acc_pct  = rep(NA_real_, N),
step_sd_hist= rep(NA_real_, N),
fam_hist  = array(NA_integer_, dim = c(M,N,K)),
par1_hist = array(NA_real_,    dim = c(M,N,K)),
par2_hist = array(NA_real_,    dim = c(M,N,K)),
ancestorIndices = matrix(0L, M, N),
risk    =  list(
dates = integer(n_oos),
mean  = matrix(NA_real_, n_oos, d, dimnames = list(NULL, tickers)),
var   = matrix(NA_real_, n_oos, d, dimnames = list(NULL, tickers)),
ci_lo = matrix(NA_real_, n_oos, d, dimnames = list(NULL, tickers)),
ci_hi = matrix(NA_real_, n_oos, d, dimnames = list(NULL, tickers)),
VaR   = array(NA_real_, dim = c(n_oos, d, A),
dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
ES    = array(NA_real_, dim = c(n_oos, d, A),
dimnames = list(NULL, tickers, paste0("a", cfg$alphas)))
),
port = list(
dates  = integer(n_oos),
mean   = numeric(n_oos),
VaR    = matrix(NA_real_, n_oos, A,
dimnames = list(NULL, paste0("a", cfg$alphas))),
ES     = matrix(NA_real_, n_oos, A,
dimnames = list(NULL, paste0("a", cfg$alphas)))
)
)
# init particles
particles <- replicate(M, new_particle(cfg), simplify = FALSE)
out$ancestorIndices[,1] <- seq_len(M)
seq_len(N)
5789-5033
source("~/Research/project_1/Code/Exploratory/smc_vines/src/scripts/run_empirical.R", echo=TRUE)
dat <- list(
U      = readRDS("data/PIT.rds")[,1:3],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[,2:4],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[,2:4],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[,2:4],#[,-1]
shape_fc = readRDS("data/shape_fc.rds")[,2:4]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
U      <- data$U
mu_fc  <- data$mu_fc
sig_fc <- data$sig_fc
df_fc     <- data$df_fc
shape_fc     <- data$shape_fc
t_train <- cfg$W_predict
skeleton <- make_skeleton_CVM(U[1:t_train, ])
cfg <- add_first_tree_map(cfg, skeleton)
shape_fc
df_fc
sig_fc
mu_fc
