states <- as.character(L_switch$states)
if (sum(lens) != T) stop("Schedule lens must sum to T.")
if (length(states) != length(lens)) stop("Schedule states must have same length as lens.")
} else {
L_fixed <- as.integer(L_switch)
n_reg <- ceiling(T / L_fixed)
lens <- rep(L_fixed, n_reg)
lens[length(lens)] <- T - sum(lens[-length(lens)])
states <- rep("NORMAL", length(lens))
}
n_reg <- length(lens)
U <- matrix(NA_real_, nrow = T, ncol = 2)
regime_id <- integer(T)
regimes <- vector("list", n_reg)
# helper: does draw_fun accept a state argument?
draw_has_arg <- (length(formals(draw_fun)) >= 1L)
t0 <- 1L
for (r in seq_len(n_reg)) {
t1 <- t0 + lens[r] - 1L
st <- states[r]
dgp_r <- if (draw_has_arg) draw_fun(st) else draw_fun()
U[t0:t1, ] <- rvinecop(lens[r], dgp_r$vc)
u_star_r <- c(
a0.05b0.05   = solve_u_star(dgp_r$vc, alpha = 0.05,  beta = 0.05),
a0.05b0.1    = solve_u_star(dgp_r$vc, alpha = 0.10,  beta = 0.05),
a0.1b0.1     = solve_u_star(dgp_r$vc, alpha = 0.10,  beta = 0.10),
a0.1b0.05    = solve_u_star(dgp_r$vc, alpha = 0.05,  beta = 0.10),
a0.05b0.025  = solve_u_star(dgp_r$vc, alpha = 0.025, beta = 0.05),
a0.025b0.05  = solve_u_star(dgp_r$vc, alpha = 0.05,  beta = 0.025)
)
regimes[[r]] <- list(
r = r,
state   = st,
t_start = t0,
t_end   = t1,
idx     = t0:t1,
vc      = dgp_r$vc,
true_bases = dgp_r$true_bases,
u_star  = u_star_r,
# optional diagnostics (won't break anything)
lambdaL = if (!is.null(dgp_r$pair_list$e12$lambdaL)) dgp_r$pair_list$e12$lambdaL else NA_real_,
lambdaU = if (!is.null(dgp_r$pair_list$e12$lambdaU)) dgp_r$pair_list$e12$lambdaU else NA_real_
)
regime_id[t0:t1] <- r
t0 <- t1 + 1L
}
true_base_by_regime <- vapply(regimes, function(g) g$true_bases[1], character(1))
true_base_t <- true_base_by_regime[regime_id]
list(U = U, regimes = regimes, regime_id = regime_id, true_base_t = true_base_t)
}
####################################################################
#
#
# make_piecewise_dgp_d2 <- function(T, L_switch, draw_fun) {
#   n_reg <- ceiling(T / L_switch)
#
#   U <- matrix(NA_real_, nrow = T, ncol = 2)
#   regime_id <- integer(T)
#   regimes <- vector("list", n_reg)
#
#   t0 <- 1L
#   for (r in seq_len(n_reg)) {
#     t1 <- min(T, t0 + L_switch - 1L)
#
#     dgp_r <- draw_fun()  # must return list with $vc and $true_bases
#     U[t0:t1, ] <- rvinecop(t1 - t0 + 1L, dgp_r$vc)
#
#     # store regime-specific truth you will need later
#     u_star_r <- c(
#       # a = conditioning beta (U1 distress), b = target alpha (U2 tail)
#       a0.05b0.05   = solve_u_star(dgp_r$vc, alpha = 0.05,  beta = 0.05),
#       a0.05b0.1    = solve_u_star(dgp_r$vc, alpha = 0.10,  beta = 0.05),
#       a0.1b0.1     = solve_u_star(dgp_r$vc, alpha = 0.10,  beta = 0.10),
#       a0.1b0.05    = solve_u_star(dgp_r$vc, alpha = 0.05,  beta = 0.10),
#
#       # NEW
#       a0.05b0.025  = solve_u_star(dgp_r$vc, alpha = 0.025, beta = 0.05),
#       a0.025b0.05  = solve_u_star(dgp_r$vc, alpha = 0.05,  beta = 0.025)
#     )
#
#     regimes[[r]] <- list(
#       r = r,
#       t_start = t0,
#       t_end   = t1,
#       idx     = t0:t1,
#       vc      = dgp_r$vc,
#       true_bases = dgp_r$true_bases,  # for d=2 should be length 1
#       u_star  = u_star_r
#     )
#
#     regime_id[t0:t1] <- r
#     t0 <- t1 + 1L
#   }
#
#   true_base_by_regime <- vapply(regimes, function(g) g$true_bases[1], character(1))
#   true_base_t <- true_base_by_regime[regime_id]
#
#   list(U = U, regimes = regimes, regime_id = regime_id, true_base_t = true_base_t)
# }
# draw one bicop_dist from the allowed set
draw_bicop <- function() {
f <- sample(fam_names, 1)
if (f == "t") {
# target moderate |tau|; map to rho; pick df
tau <- runif(1, 0.2, 0.8) * 1#sample(c(-1, 1), 1)
rho <- sin(pi * tau / 2)
nu  <- runif(1, 2, 7)
list(name_base = "t",
bic       = bicop_dist("t", 0, c(rho, nu)))
} else if (f %in% c("bb1")) {
# BB1: theta>0, delta>=1  (keep in stable ranges)
theta <- runif(1, 0, 7)
delta <- runif(1, 1, 7)
rot   <- 0
list(name_base = "bb1",
bic       = bicop_dist("bb1", rot, c(theta, delta)))
} else if (f %in% c("bb1r180")) {
# BB1: theta>0, delta>=1  (keep in stable ranges)
theta <- runif(1, 0, 7)
delta <- runif(1, 1, 7)
rot   <- ifelse(f == "bb1r180", 180, 0)
list(name_base = "bb1r180",
bic       = bicop_dist("bb1", rot, c(theta, delta)))
} else if (f %in% c("bb7")) {
# BB7: theta>=1, delta>0
theta <- runif(1, 1, 6.0)
delta <- runif(1, 0.01, 25)
rot   <- 0
list(name_base = "bb7",
bic       = bicop_dist("bb7", rot, c(theta, delta)))
} else if (f %in% c("bb7r180")) {
# BB7: theta>=1, delta>0
theta <- runif(1, 1, 6.0)
delta <- runif(1, 0.01, 25)
rot   <- ifelse(f == "bb7r180", 180, 0)
list(name_base = "bb7r180",
bic       = bicop_dist("bb7", rot, c(theta, delta)))
} else stop("unknown family requested")
}
# install.packages("VineCopula")
library(VineCopula)
# BB1 family code in VineCopula = 7
bb1_tail_dependence <- function(theta, delta) {
out <- BiCopPar2TailDep(family = 9, par = theta, par2 = delta)
c(lower = out$lower, upper = out$upper)
}
# Example
bb1_tail_dependence(theta = 1, delta = 1
)
# clamp01_2 <- function(x, eps = 1e-6) pmin(pmax(x, eps), 1 - eps)
#
# # This is now your draw_bicop()
# draw_bicop <- function(
#     td_ranges = list(
#       # calm (symmetric, mild)
#       t   = c(0.02, 0.12),
#
#       # contenders in the bulk: mild tails (both small)
#       bb1 = list(L = c(0.02, 0.15), U = c(0.02, 0.15)),
#       bb7 = list(L = c(0.02, 0.15), U = c(0.02, 0.15)),
#
#       # stress: strong lower tail, weak upper tail (crash dependence)
#       bb1r180 = list(L = c(0.40, 0.80), U = c(0.01, 0.08)),
#       bb7r180 = list(L = c(0.40, 0.80), U = c(0.01, 0.08))
#     ),
#     nu_range = c(5, 30),   # calmer t when needed
#     eps = 1e-6
# ) {
#   # uses global fam_names like your original code
#   f <- sample(fam_names, 1)
#
#   if (f == "t") {
#     lam <- clamp01_2(runif(1, td_ranges$t[1], td_ranges$t[2]), eps)
#     nu  <- runif(1, nu_range[1], nu_range[2])
#     rho <- t_tail2rho(lam, nu)
#     bic <- bicop_dist("t", 0, c(rho, nu))
#     return(list(name_base = "t", bic = bic, lambdaL = lam, lambdaU = lam, par = c(rho, nu)))
#   }
#
#   draw_lams <- function(key) {
#     lamL <- clamp01_2(runif(1, td_ranges[[key]]$L[1], td_ranges[[key]]$L[2]), eps)
#     lamU <- clamp01_2(runif(1, td_ranges[[key]]$U[1], td_ranges[[key]]$U[2]), eps)
#     list(lamL = lamL, lamU = lamU)
#   }
#
#   if (f == "bb1") {
#     l   <- draw_lams("bb1")
#     par <- bb1_tail2par(l$lamL, l$lamU)
#     bic <- bicop_dist("bb1", 0, par)
#     return(list(name_base = "bb1", bic = bic, lambdaL = l$lamL, lambdaU = l$lamU, par = par))
#   }
#
#   if (f == "bb1r180") {
#     l   <- draw_lams("bb1r180")
#     par <- bb1_tail2par(l$lamL, l$lamU)
#     bic <- bicop_dist("bb1", 180, par)
#     return(list(name_base = "bb1r180", bic = bic, lambdaL = l$lamL, lambdaU = l$lamU, par = par))
#   }
#
#   if (f == "bb7") {
#     l   <- draw_lams("bb7")
#     par <- bb7_tail2par(l$lamL, l$lamU)
#     bic <- bicop_dist("bb7", 0, par)
#     return(list(name_base = "bb7", bic = bic, lambdaL = l$lamL, lambdaU = l$lamU, par = par))
#   }
#
#   if (f == "bb7r180") {
#     l   <- draw_lams("bb7r180")
#     par <- bb7_tail2par(l$lamL, l$lamU)
#     bic <- bicop_dist("bb7", 180, par)
#     return(list(name_base = "bb7r180", bic = bic, lambdaL = l$lamL, lambdaU = l$lamU, par = par))
#   }
#
#   stop("unknown family requested")
# }
draw_vine_d2 <- function() {
e12   <- draw_bicop()
list(
vc = vinecop_dist(
pair_copulas = list(
list(e12$bic)  # tree 1
),
structure = cvine_structure(2:1)  # <-- full C-vine for d=3
),
true_bases = c(e12$name_base),
pair_list  = list(e12=e12)
)
}
test_loglik <- function(model, Utest) sum(na.omit(log(dvinecop(Utest, model))))
q_sstd <- function(u) qsstd(u, mean = 0, sd = 1, nu = 3, xi = 0.9)
# solve u* from C(beta, u*) = alpha*beta using the TRUE bivariate copula
solve_u_star <- function(bic, alpha, beta) {
target <- alpha * beta
f <- function(u) pbicop(cbind(beta, u), family = bic$pair_copulas[[1]][[1]]$family,
rotation = bic$pair_copulas[[1]][[1]]$rotation,
parameters = bic$pair_copulas[[1]][[1]]$parameters )  - target
uniroot(f, interval = c(1e-12, 1 - 1e-12))$root
}
############
rmse <- function(x, y, na.rm = TRUE) {
if (na.rm) {
ok <- is.finite(x) & is.finite(y)
x <- x[ok]; y <- y[ok]
}
sqrt(mean((x - y)^2))
}
mae <- function(x, y, na.rm = TRUE) {
if (na.rm) {
ok <- is.finite(x) & is.finite(y)
x <- x[ok]; y <- y[ok]
}
mean(abs(x - y))
}
#------------------------------------------------------------
# Compare out$CoVaR_tail (n_test x 2 x 4) against truth series
# - Uses only scenarios: a0.05b0.05 -> covar_true_5
#                         a0.1b0.1  -> covar_true_10
# - Aligns by taking last n_test points from truth (since truth includes train)
#------------------------------------------------------------
covar_rmse_mae <- function(out, dgp,
n_test = dim(out$CoVaR_tail)[1],
scen_names = dimnames(out$CoVaR_tail)[[3]],
map = list(
a0.05b0.05 = "covar_true_5",
a0.1b0.1   = "covar_true_10"
),
na.rm = TRUE) {
# --- sanity checks
if (is.null(out$CoVaR_tail)) stop("out$CoVaR_tail not found.")
if (length(dim(out$CoVaR_tail)) != 3) stop("out$CoVaR_tail must be a 3D array: (time x cond_asset x scenario).")
if (dim(out$CoVaR_tail)[2] != 2) stop("Expected 2 conditioning assets in out$CoVaR_tail (dim[,2] = 2).")
if (is.null(scen_names)) stop("Scenario names missing: add dimnames(out$CoVaR_tail)[[3]].")
# build output holder
res <- data.frame(
scenario = character(0),
truth_obj = character(0),
cond_asset = integer(0),
RMSE = numeric(0),
MAE  = numeric(0),
stringsAsFactors = FALSE
)
# loop over selected scenarios
for (sc in names(map)) {
truth_name <- map[[sc]]
if (!(sc %in% scen_names)) {
stop(sprintf("Scenario '%s' not found in dimnames(out$CoVaR_tail)[[3]].", sc))
}
if (is.null(dgp$truth[[truth_name]])) {
stop(sprintf("dgp$truth$%s not found.", truth_name))
}
truth_mat <- dgp$truth[[truth_name]]
if (!is.matrix(truth_mat) || ncol(truth_mat) != 2) {
stop(sprintf("dgp$truth$%s must be a matrix with 2 columns (assets).", truth_name))
}
# align: use last n_test rows from truth
if (nrow(truth_mat) < n_test) {
stop(sprintf("Truth series '%s' has only %d rows but need at least n_test=%d.",
truth_name, nrow(truth_mat), n_test))
}
truth_last <- truth_mat[(nrow(truth_mat) - n_test + 1):nrow(truth_mat), , drop = FALSE]
# predicted slice for this scenario: (n_test x 2 cond_assets)
pred_slice <- out$CoVaR_tail[, , sc, drop = FALSE][, , 1]
# compute errors for each conditioning asset (dimension 2)
for (j in 1:2) {
pred_j  <- pred_slice[, j]
truth_j <- truth_last[, j]
res <- rbind(res, data.frame(
scenario = sc,
truth_obj = truth_name,
cond_asset = j,
RMSE = rmse(pred_j, truth_j, na.rm = na.rm),
MAE  = mae(pred_j, truth_j, na.rm = na.rm),
stringsAsFactors = FALSE
))
}
}
res
}
covar_rmse_mae_all <- function(out, dgp,
n_test = dim(out$CoVaR_tail)[1],
scen_names = dimnames(out$CoVaR_tail)[[3]],
map = NULL,
na.rm = TRUE) {
# --- sanity checks
if (is.null(out$CoVaR_tail)) stop("out$CoVaR_tail not found.")
if (length(dim(out$CoVaR_tail)) != 3) stop("out$CoVaR_tail must be a 3D array: (time x cond_asset x scenario).")
if (dim(out$CoVaR_tail)[2] != 2) stop("Expected 2 conditioning assets in out$CoVaR_tail (dim[,2] = 2).")
if (is.null(scen_names)) stop("Scenario names missing: add dimnames(out$CoVaR_tail)[[3]].")
# --- default mapping: ALL FOUR scenarios
# assumes you stored truth as:
# dgp$truth$covar_true_a05b05, covar_true_a05b10, covar_true_a10b10, covar_true_a10b05
if (is.null(map)) {
map <- list(
a0.05b0.05  = "covar_true_a05b05",
a0.05b0.1   = "covar_true_a05b10",
a0.1b0.1    = "covar_true_a10b10",
a0.1b0.05   = "covar_true_a10b05",
# NEW
a0.05b0.025 = "covar_true_a05b0025",
a0.025b0.05 = "covar_true_a0025b05"
)
}
# build output holder
res <- data.frame(
scenario   = character(0),
truth_obj  = character(0),
cond_asset = integer(0),
RMSE       = numeric(0),
MAE        = numeric(0),
stringsAsFactors = FALSE
)
# loop over selected scenarios
for (sc in names(map)) {
truth_name <- map[[sc]]
if (!(sc %in% scen_names)) {
stop(sprintf("Scenario '%s' not found in dimnames(out$CoVaR_tail)[[3]]. Available: %s",
sc, paste(scen_names, collapse = ", ")))
}
if (is.null(dgp$truth[[truth_name]])) {
stop(sprintf("dgp$truth$%s not found.", truth_name))
}
truth_mat <- dgp$truth[[truth_name]]
if (!is.matrix(truth_mat) || ncol(truth_mat) != 2) {
stop(sprintf("dgp$truth$%s must be a matrix with 2 columns (assets).", truth_name))
}
# align: use last n_test rows from truth
if (nrow(truth_mat) < n_test) {
stop(sprintf("Truth series '%s' has only %d rows but need at least n_test=%d.",
truth_name, nrow(truth_mat), n_test))
}
truth_last <- truth_mat[(nrow(truth_mat) - n_test + 1):nrow(truth_mat), , drop = FALSE]
# predicted slice for this scenario: (n_test x 2 cond_assets)
pred_slice <- out$CoVaR_tail[, , sc, drop = FALSE][, , 1]
# compute errors for each conditioning asset (dimension 2)
for (j in 1:2) {
pred_j  <- pred_slice[, j]
truth_j <- truth_last[, j]
res <- rbind(res, data.frame(
scenario   = sc,
truth_obj  = truth_name,
cond_asset = j,
RMSE       = rmse(pred_j, truth_j, na.rm = na.rm),
MAE        = mae(pred_j, truth_j, na.rm = na.rm),
stringsAsFactors = FALSE
))
}
}
res
}
#############
# var_list <- vector("list", n_sim)
# covar_list <- vector("list", n_sim)
# logpred_list <- vector("list", n_sim)
# QL_list <- vector("list", n_sim)
# FZL_list <- vector("list", n_sim)
# wCRPS_list <- vector("list", n_sim)
# rmse_mae_from_covar_list <- vector("list", n_sim)
#
alphas_covar <- c(0.025, 0.05, 0.10)
betas_covar  <- c(0.025, 0.05, 0.10)
source(here("src/R", "config.R"))
source(here("src/simulation/naive_simulation.R"))
source(here("src/simulation/main_simulation_nonparallel.R"))
s=1
set.seed(1111 + s)
Ttot <- n_train + n_test
L_switch <- 100L  # <- choose your "every x observations" here (or put inside cfg)
n_train=756
Ttot <- n_train + n_test
n_test=3000
Ttot <- n_train + n_test
L_switch <- 100L  # <- choose your "every x observations" here (or put inside cfg)
# choose mean regime length (50 or 100) and extreme time share
sched <- make_regime_schedule(
T = Ttot,
mean_len  = 1000000L,   # or 50L
p_extreme = 0.10,   # e.g., 20% of time in EXTREME lower-tail regimes
min_len = 20L,
max_len = 2000000L
)
sched
bb1_tail2par(0.01, .01)
par <- bb1_tail2par(0.01, .01)
par
par <- bb1_tail2par(0.01, .01)
bicop_dist("bb1", 0L, par)
par <- bb1_tail2par(0.01, .0)
bicop_dist("bb1", 0L, par)
par <- bb1_tail2par(0.01, -.0)
bicop_dist("bb1", 0L, par)
par <- bb1_tail2par(0.01, -1.0)
bicop_dist("bb1", 0L, par)
bb1_par2tail(0.0, 1.0)
bb1_par2tail(0.87, 1.0)
par <- bb1_tail2par(0.87, .2)
par
bicop_dist("bb1", 0L, par)
par <- bb1_tail2par(0.87, 1)
par
bicop_dist("bb1", 0L, par)
par <- bb1_tail2par(0.87, 1)
par
par <- bb1_tail2par(0.87, 0.99)
par
bicop_dist("bb1", 0L, par)
par <- bb1_tail2par(0.01, 0.95)
par
par <- bb1_tail2par(0.01, 0.9)
par
par <- bb1_tail2par(0.01, 0.87)
par
par <- bb1_tail2par(0.01, 0.88)
par
par <- bb1_tail2par(0.01, 0.89)
par
par <- bb1_tail2par(0.01, 0.89)
par
bicop_dist("bb1", 0L, par)
bicop_dist("bb1", 180L, par)
bb1_par2tail(0.1, 7)
bb1_par2tail(0.01, 7)
par <- bb7_tail2par(0.01, 0.89)
par
bicop_dist("bb1", 180L, par)
par
par <- bb7_tail2par(0.01, 0.87)
par
bicop_dist("bb1", 180L, par)
par <- bb7_tail2par(0.05, 0.87)
par
bicop_dist("bb1", 180L, par)
par <- bb7_tail2par(0.05, 0.85)
par
bicop_dist("bb1", 180L, par)
par <- bb7_tail2par(0.05, 0.8)
par
par <- bb7_tail2par(0.05, 0.89)
par
bicop_dist("bb7", 180L, par)
bicop_dist("bb7", 0L, par)
par
par <- bb7_tail2par(0.01, 0.89)
par
lamU_target <- runif(1, 0.05, 0.50)
par <- bb7_tail2par(0.05, 0.89)
par
bicop_dist("bb7", 0L, par)
par <- bb7_tail2par(0.05, 0.88)
par
par <- bb7_tail2par(0.05, 0.87)
par
par <- bb7_tail2par(0.01, 0.87)
par
bicop_dist("bb7", 0L, par)
bicop_dist("bb7", 180L, par)
folder <- "simul_results/2d_SMC_grid/mlNA_pext000_tipk012_wp0756_re001"   # <- change this
files  <- list.files(folder, pattern = "\\.rds$", full.names = TRUE)
# read all files (each file is assumed to be a list)
obj_list <- lapply(files, readRDS)
# extract the element you want (file[[1]]$covar, file[[2]]$covar, ...)
covar_list <- lapply(obj_list, `[[`, "eval_covar")
# (optional) keep only non-missing covar elements
covar_list <- Filter(Negate(is.null), covar_list)
# bind vertically
covar_all <- do.call(rbind, covar_list)
covar_all
with(covar_all, mean(rate[asset == 2 & alpha_j == 0.05 & alpha_port == 0.05], na.rm = TRUE))
with(covar_all, mean(rate[asset == 2 & alpha_j == 0.05 & alpha_port == 0.025], na.rm = TRUE))
with(covar_all, mean(rate[asset == 2 & alpha_j == 0.1 & alpha_port == 0.1], na.rm = TRUE))
252*0.05
252*0.1
sqrt(252)
