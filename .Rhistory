p_bb1,
s_lamU[1], s_lamU[2], s_lamU[3], s_lamU[4],
s_lamL[1], s_lamL[2], s_lamL[3], s_lamL[4],
s_th1[1],  s_th1[2],
s_th2[1],  s_th2[2]))
}
## BB1^180 (survival) stats – rotated tail map
if (p_bb1r > 0) {
mask    <- fam_mat[, e] == BB1s
th1_e   <- th1_mat[mask, e]; th2_e <- th2_mat[mask, e]
lam_rot <- t(mapply(bb1r180_par2tail, th1_e, th2_e))  # (λL_rot, λU_rot)
w_br    <- w_new[mask] / p_bb1r
stats <- function(x) {
mu <- sum(w_br * x)
sd <- sqrt(sum(w_br * (x - mu)^2))
ci <- w_quantile(x, w_br, q_probs)
c(mu, sd, ci)
}
s_lamLr <- stats(lam_rot[, 1]); s_lamUr <- stats(lam_rot[, 2])
s_th1r  <- stats(th1_e);        s_th2r  <- stats(th2_e)
res <- c(res,
list(mu_lambdaL_rot = s_lamLr[1], sd_lambdaL_rot = s_lamLr[2],
lamL_rot_q025  = s_lamLr[3], lamL_rot_q975  = s_lamLr[4],
mu_lambdaU_rot = s_lamUr[1], sd_lambdaU_rot = s_lamUr[2],
lamU_rot_q025  = s_lamUr[3], lamU_rot_q975  = s_lamUr[4],
mu_theta_rot   = s_th1r[1],  sd_theta_rot   = s_th1r[2],
theta_rot_q025 = s_th1r[3],  theta_rot_q975 = s_th1r[4],
mu_delta_rot   = s_th2r[1],  sd_delta_rot   = s_th2r[2],
delta_rot_q025 = s_th2r[3],  delta_rot_q975 = s_th2r[4]))
if (print_flag)
cat(sprintf(
"                BB1^180 : P=%.3f | λU(rot)=%.3f±%.3f CI=[%.3f,%.3f] | λL(rot)=%.3f±%.3f CI=[%.3f,%.3f] | θ=%.2f±%.2f | δ=%.2f±%.2f\n",
p_bb1r,
s_lamUr[1], s_lamUr[2], s_lamUr[3], s_lamUr[4],
s_lamLr[1], s_lamLr[2], s_lamLr[3], s_lamLr[4],
s_th1r[1],  s_th1r[2],
s_th2r[1],  s_th2r[2]))
}
## BB8^180 parameter stats (no tail map here)
if (p_bb8r > 0) {
mask   <- fam_mat[, e] == BB8s
th1_e  <- th1_mat[mask, e]; th2_e <- th2_mat[mask, e]
w_b8   <- w_new[mask] / p_bb8r
stats <- function(x) {
mu <- sum(w_b8 * x)
sd <- sqrt(sum(w_b8 * (x - mu)^2))
ci <- w_quantile(x, w_b8, q_probs)
c(mu, sd, ci)
}
s_th1 <- stats(th1_e)
s_th2 <- stats(th2_e)
res <- c(res,
list(mu_bb8r_theta = s_th1[1], sd_bb8r_theta = s_th1[2],
bb8r_theta_q025 = s_th1[3], bb8r_theta_q975 = s_th1[4],
mu_bb8r_delta = s_th2[1], sd_bb8r_delta = s_th2[2],
bb8r_delta_q025 = s_th2[3], bb8r_delta_q975 = s_th2[4]))
if (print_flag)
cat(sprintf(
"                BB8^180 : P=%.3f | θ=%.2f±%.2f CI=[%.2f,%.2f] | δ=%.2f±%.2f CI=[%.2f,%.2f]\n",
p_bb8r,
s_th1[1], s_th1[2], s_th1[3], s_th1[4],
s_th2[1], s_th2[2], s_th2[3], s_th2[4]))
}
## BB7 (Joe–Clayton) parameter stats
if (p_bb7 > 0) {
mask  <- fam_mat[, e] == BB7
th1_e <- th1_mat[mask, e]; th2_e <- th2_mat[mask, e]
wloc  <- w_new[mask] / p_bb7
stats <- function(x){
mu <- sum(wloc * x)
sd <- sqrt(sum(wloc * (x - mu)^2))
qs <- w_quantile(x, wloc, q_probs)
c(mu, sd, qs)
}
s1 <- stats(th1_e); s2 <- stats(th2_e)
res <- c(res,
list(mu_bb7_theta = s1[1], sd_bb7_theta = s1[2],
bb7_theta_q025 = s1[3], bb7_theta_q975 = s1[4],
mu_bb7_delta = s2[1], sd_bb7_delta = s2[2],
bb7_delta_q025 = s2[3], bb7_delta_q975 = s2[4]))
if (print_flag)
cat(sprintf(
"                BB7     : P=%.3f | θ=%.2f±%.2f CI=[%.2f,%.2f] | δ=%.2f±%.2f CI=[%.2f,%.2f]\n",
p_bb7,
s1[1], s1[2], s1[3], s1[4],
s2[1], s2[2], s2[3], s2[4]
))
}
## BB7^180 (rotated) parameter stats
if (p_bb7r > 0) {
mask  <- fam_mat[, e] == BB7s
th1_e <- th1_mat[mask, e]; th2_e <- th2_mat[mask, e]
wloc  <- w_new[mask] / p_bb7r
stats <- function(x){
mu <- sum(wloc * x)
sd <- sqrt(sum(wloc * (x - mu)^2))
qs <- w_quantile(x, wloc, q_probs)
c(mu, sd, qs)
}
s1 <- stats(th1_e); s2 <- stats(th2_e)
res <- c(res,
list(mu_bb7r_theta = s1[1], sd_bb7r_theta = s1[2],
bb7r_theta_q025 = s1[3], bb7r_theta_q975 = s1[4],
mu_bb7r_delta = s2[1], sd_bb7r_delta = s2[2],
bb7r_delta_q025 = s2[3], bb7r_delta_q975 = s2[4]))
if (print_flag)
cat(sprintf(
"                BB7^180 : P=%.3f | θ=%.2f±%.2f CI=[%.2f,%.2f] | δ=%.2f±%.2f CI=[%.2f,%.2f]\n",
p_bb7r,
s1[1], s1[2], s1[3], s1[4],
s2[1], s2[2], s2[3], s2[4]
))
}
edge_summ[[e]] <- res
}
edge_df <- data.table::rbindlist(edge_summ, fill = TRUE)
invisible(list(
ESS      = ess_t,
unique   = n_unique,
euc      = avg_dist,
sparsity = sparsity,
edges    = edge_df
))
}
# diagnostics
dg <- diagnostic_report(t, 0, U, particles, w, cfg)
out$diag_log[t, `:=`(t        = t,
ESS      = dg$ESS,
unique   = dg$unique,
euc      = dg$euc,
sparsity = dg$sparsity)]
newAnc <- stratified_resample(w)
data_up_to_t <- U[max(1, t - cfg$W + 1):t, , drop = FALSE]
move_out <- resample_move_old(particles, newAnc, data_up_to_t, cl,
cfg$type, cfg, skeleton = skeleton)
library(here)
source(here("src/R", "config.R"))
n_assets <- 1:7
n_days <- 1:3000
dat <- list(
U      = readRDS("data/PIT.rds")[1:length(n_days),n_assets],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[n_days,(n_assets+1), with = FALSE],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[n_days,(n_assets+1), with = FALSE],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[n_days,(n_assets+1), with = FALSE],#[,-1]
shape_fc = readRDS("data/shape_fc.rds")[n_days,(n_assets+1), with = FALSE],
y_real = readRDS("data/returns_actual.rds")[n_days,n_assets+1, with = FALSE]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
cfg
U      <- data$U
mu_fc  <- data$mu_fc
sig_fc <- data$sig_fc
df_fc     <- data$df_fc
shape_fc     <- data$shape_fc
y_real <- data$y_real
t_train <- cfg$W_predict
skeleton <- make_skeleton_CVM(U[1:t_train, ], trunc_tree = cfg$trunc_tree)
cfg$trunc_tree
skeleton <- make_skeleton_CVM(U[1:t_train, ], trunc_tree = cfg$trunc_tree)
skeleton
cfg <- add_first_tree_map(cfg, skeleton)
exports <- c(
# constants & templates
"FAM_INFO", "FAM_INDEP", "FAM_GAUSS", "FAM_BB1", "FAM_BB1R180",
"T_INDEP",  "T_GAUSS",   "T_BB1", "T_BB1R180", "FAM_BB8R180",
"FAM_BB7","FAM_BB7R180","T_BB8R180","T_BB7","T_BB7R180",
# helper functions
"active_fams", "sanitize_bb1", "mh_worker_standard", "mh_worker_block",
"bb1r180_tail2par", "bb1r180_par2tail", "bb1r180_log_jacobian",
"bb7_tail2par","bb7_par2tail","bb7_log_jacobian","bb7r180_tail2par","bb7r180_par2tail",
"bb7r180_log_jacobian","bb8r180_tail2par","bb8r180_par2tail","bb8r180_log_jacobian_1d",
"sanitize_bb7","sanitize_bb8",
# core SMC kernels
"mh_step", "mh_step_in_tree",
"update_weights", "ESS", "systematic_resample", "resample_move",
# log-target & proposals
"log_prior", "bb1_tail2par", "bb1_par2tail", "bb1_log_jacobian",
"rtnorm_vec", "log_prior_edge",
# likelihood helpers
"bicop_dist", "vinecop_dist", "dvinecop", "fast_vine_from_particle",
"rvinecop","bicop",
# shared data objects
"skeleton", "cfg",
# diagnostics & prediction
"diagnostic_report", "compute_predictive_metrics",
"compute_log_incr",
# small utilities
"w_mean", "w_var", "mc_se", "w_quantile", "fillna_neg", "fam_spec"
)
cl <- make_cluster(cfg$nc, cfg$seed, exports)
M <- cfg$M; K <- cfg$K; N <- nrow(U); d <- cfg$d; n_oos <- N - cfg$W_predict
tickers    <- colnames(U); A <- length(cfg$alphas)
out <- list(
log_pred    = numeric(n_oos),
diag_log    = data.table(t = integer(N), ESS = numeric(N), unique = integer(N), euc = numeric(N), sparsity = numeric(N)),
mh_acc_pct  = rep(NA_real_, N),
step_sd_hist= rep(NA_real_, N),
fam_hist  = array(NA_integer_, dim = c(M,N,K)),
par1_hist = array(NA_real_,    dim = c(M,N,K)),
par2_hist = array(NA_real_,    dim = c(M,N,K)),
rotation_hist = array(NA_real_, dim = c(M,N,K)),
ancestorIndices = matrix(0L, M, N),
risk    =  list(
dates = integer(n_oos),
VaR   = array(NA_real_, dim = c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
ES    = array(NA_real_, dim = c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas)))
),
QL    = array(NA_real_, c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
FZL   = array(NA_real_, c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
wCRPS = matrix(NA_real_, n_oos, d, dimnames = list(NULL, tickers)),
port = list(
dates  = integer(n_oos),
VaR    = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
ES     = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
QL    = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
FZL   = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
wCRPS = numeric(n_oos)
),
CoVaR_tail = array(NA_real_, c(n_oos, d, 2), dimnames = list(NULL, tickers, c("a0.05","a0.10")))
)
cfg$K
library(here)
source(here("src/R", "config.R"))
n_assets <- 1:7
n_days <- 1:3000
dat <- list(
U      = readRDS("data/PIT.rds")[1:length(n_days),n_assets],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[n_days,(n_assets+1), with = FALSE],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[n_days,(n_assets+1), with = FALSE],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[n_days,(n_assets+1), with = FALSE],#[,-1]
shape_fc = readRDS("data/shape_fc.rds")[n_days,(n_assets+1), with = FALSE],
y_real = readRDS("data/returns_actual.rds")[n_days,n_assets+1, with = FALSE]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
y_real <- data$y_real
exports <- c(
# constants & templates
"FAM_INFO", "FAM_INDEP", "FAM_GAUSS", "FAM_BB1", "FAM_BB1R180",
"T_INDEP",  "T_GAUSS",   "T_BB1", "T_BB1R180", "FAM_BB8R180",
"FAM_BB7","FAM_BB7R180","T_BB8R180","T_BB7","T_BB7R180",
# helper functions
"active_fams", "sanitize_bb1", "mh_worker_standard", "mh_worker_block",
"bb1r180_tail2par", "bb1r180_par2tail", "bb1r180_log_jacobian",
"bb7_tail2par","bb7_par2tail","bb7_log_jacobian","bb7r180_tail2par","bb7r180_par2tail",
"bb7r180_log_jacobian","bb8r180_tail2par","bb8r180_par2tail","bb8r180_log_jacobian_1d",
"sanitize_bb7","sanitize_bb8",
# core SMC kernels
"mh_step", "mh_step_in_tree",
"update_weights", "ESS", "systematic_resample", "resample_move",
# log-target & proposals
"log_prior", "bb1_tail2par", "bb1_par2tail", "bb1_log_jacobian",
"rtnorm_vec", "log_prior_edge",
# likelihood helpers
"bicop_dist", "vinecop_dist", "dvinecop", "fast_vine_from_particle",
"rvinecop","bicop",
# shared data objects
"skeleton", "cfg",
# diagnostics & prediction
"diagnostic_report", "compute_predictive_metrics",
"compute_log_incr",
# small utilities
"w_mean", "w_var", "mc_se", "w_quantile", "fillna_neg", "fam_spec"
)
cl <- make_cluster(cfg$nc, cfg$seed, exports)
M <- cfg$M; K <- cfg$K; N <- nrow(U); d <- cfg$d; n_oos <- N - cfg$W_predict
library(here)
source(here("src/R", "config.R"))
n_assets <- 1:7
n_days <- 1:3000
dat <- list(
U      = readRDS("data/PIT.rds")[1:length(n_days),n_assets],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[n_days,(n_assets+1), with = FALSE],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[n_days,(n_assets+1), with = FALSE],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[n_days,(n_assets+1), with = FALSE],#[,-1]
shape_fc = readRDS("data/shape_fc.rds")[n_days,(n_assets+1), with = FALSE],
y_real = readRDS("data/returns_actual.rds")[n_days,n_assets+1, with = FALSE]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
U      <- data$U
mu_fc  <- data$mu_fc
sig_fc <- data$sig_fc
df_fc     <- data$df_fc
shape_fc     <- data$shape_fc
y_real <- data$y_real
t_train <- cfg$W_predict
skeleton <- make_skeleton_CVM(U[1:t_train, ], trunc_tree = cfg$trunc_tree)
cfg <- add_first_tree_map(cfg, skeleton)
exports <- c(
# constants & templates
"FAM_INFO", "FAM_INDEP", "FAM_GAUSS", "FAM_BB1", "FAM_BB1R180",
"T_INDEP",  "T_GAUSS",   "T_BB1", "T_BB1R180", "FAM_BB8R180",
"FAM_BB7","FAM_BB7R180","T_BB8R180","T_BB7","T_BB7R180",
# helper functions
"active_fams", "sanitize_bb1", "mh_worker_standard", "mh_worker_block",
"bb1r180_tail2par", "bb1r180_par2tail", "bb1r180_log_jacobian",
"bb7_tail2par","bb7_par2tail","bb7_log_jacobian","bb7r180_tail2par","bb7r180_par2tail",
"bb7r180_log_jacobian","bb8r180_tail2par","bb8r180_par2tail","bb8r180_log_jacobian_1d",
"sanitize_bb7","sanitize_bb8",
# core SMC kernels
"mh_step", "mh_step_in_tree",
"update_weights", "ESS", "systematic_resample", "resample_move",
# log-target & proposals
"log_prior", "bb1_tail2par", "bb1_par2tail", "bb1_log_jacobian",
"rtnorm_vec", "log_prior_edge",
# likelihood helpers
"bicop_dist", "vinecop_dist", "dvinecop", "fast_vine_from_particle",
"rvinecop","bicop",
# shared data objects
"skeleton", "cfg",
# diagnostics & prediction
"diagnostic_report", "compute_predictive_metrics",
"compute_log_incr",
# small utilities
"w_mean", "w_var", "mc_se", "w_quantile", "fillna_neg", "fam_spec"
)
cl <- make_cluster(cfg$nc, cfg$seed, exports)
M <- cfg$M; K <- cfg$K; N <- nrow(U); d <- cfg$d; n_oos <- N - cfg$W_predict
tickers    <- colnames(U); A <- length(cfg$alphas)
out <- list(
log_pred    = numeric(n_oos),
diag_log    = data.table(t = integer(N), ESS = numeric(N), unique = integer(N), euc = numeric(N), sparsity = numeric(N)),
mh_acc_pct  = rep(NA_real_, N),
step_sd_hist= rep(NA_real_, N),
fam_hist  = array(NA_integer_, dim = c(M,N,K)),
par1_hist = array(NA_real_,    dim = c(M,N,K)),
par2_hist = array(NA_real_,    dim = c(M,N,K)),
rotation_hist = array(NA_real_, dim = c(M,N,K)),
ancestorIndices = matrix(0L, M, N),
risk    =  list(
dates = integer(n_oos),
VaR   = array(NA_real_, dim = c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
ES    = array(NA_real_, dim = c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas)))
),
QL    = array(NA_real_, c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
FZL   = array(NA_real_, c(n_oos, d, A), dimnames = list(NULL, tickers, paste0("a", cfg$alphas))),
wCRPS = matrix(NA_real_, n_oos, d, dimnames = list(NULL, tickers)),
port = list(
dates  = integer(n_oos),
VaR    = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
ES     = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
QL    = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
FZL   = matrix(NA_real_, n_oos, A, dimnames = list(NULL, paste0("a", cfg$alphas))),
wCRPS = numeric(n_oos)
),
CoVaR_tail = array(NA_real_, c(n_oos, d, 2), dimnames = list(NULL, tickers, c("a0.05","a0.10")))
)
# init particles
particles <- replicate(M, new_particle(cfg), simplify = FALSE)
out$ancestorIndices[,1] <- seq_len(M)
particles[[1]]
particles[[2]]
particles[[3]]
particles[[4]]
for (t in seq_len(N)) {
#if (t==10){break}
u_t <- U[t,,drop=FALSE]
# weight-update
log_inc <- compute_log_incr(particles, u_t, skeleton, cfg)
particles <- update_weights(particles, log_inc)
w <- vapply(particles, `[[`, numeric(1), "w")
# prediction
if (t > cfg$W_predict) {
# log predictive density, predictive draws, risk metrics
idx <- t - cfg$W_predict
y_real_t <- y_real[idx,]
out$log_pred[idx] <- compute_predictive_metrics(u_t, particles, skeleton, w/sum(w), cfg)$log_pred_density
#draws <- smc_predictive_sample(particles, skeleton, w/sum(w), L = 10000, cl = cl)
draws <- smc_predictive_sample_fast(particles, skeleton, w/sum(w), L = 10000, cl = cl)
Z_pred <- st_inv_fast(draws, shape_fc[idx, ], df_fc[idx, ])
R_t  <- sweep(Z_pred, 2, as.numeric(sig_fc[idx, ]), `*`) + as.numeric(mu_fc[idx, ])          # L × d
rs <- risk_stats_full(R_t, cfg$alphas)
out$risk$dates[idx]   <- t
out$risk$VaR [idx, , ] <- rs$VaR          # d × A
out$risk$ES  [idx, , ] <- rs$ES
# EW-portfolio metrics
r_p  <- rowMeans(R_t)
ps   <- port_stats(r_p, cfg$alphas)
out$port$dates[idx]   <- t
out$port$VaR [idx, ]  <- ps$VaR
out$port$ES  [idx, ]  <- ps$ES
r_p_real <- mean(as.numeric(y_real_t))
out$port$QL[idx, ]   <- vapply(seq_along(cfg$alphas), function(k) pinball_loss(r_p_real, ps$VaR[k], cfg$alphas[k]), numeric(1))
out$port$FZL[idx, ]  <- vapply(seq_along(cfg$alphas), function(k) fzl_pzc_scalar(r_p_real, ps$VaR[k], ps$ES[k], cfg$alphas[k]), numeric(1))
out$port$wCRPS[idx]  <- wcrps_gr_scalar(r_p, r_p_real)
out$QL[idx, , ]  <- pinball_matrix(as.matrix(y_real_t[1, ]), rs$VaR, cfg$alphas) # Quantile loss per asset & alpha using the VaR you already computed
out$FZL[idx, , ] <- fzl_pzc_matrix(as.matrix(y_real_t[1, ]), rs$VaR, rs$ES, cfg$alphas) # FZL joint loss for (VaR, ES)
out$wCRPS[idx, ] <- wcrps_gr_matrix(R_t, as.matrix(y_real_t[1, ])) # Weighted CRPS from predictive draws 'R_t' and realization
# CoVaR
k5  <- which.min(abs(cfg$alphas - 0.05))
k10 <- which.min(abs(cfg$alphas - 0.10))
VaRj_5  <- rs$VaR[, k5]   # d-vector
VaRj_10 <- rs$VaR[, k10]
covar5  <- covar_tail_vec(R_t, r_p, VaRj_5,  port_alpha = 0.05, minN = 50)
covar10 <- covar_tail_vec(R_t, r_p, VaRj_10, port_alpha = 0.10, minN = 50)
out$CoVaR_tail[idx, , "a0.05"] <- covar5
out$CoVaR_tail[idx, , "a0.10"] <- covar10
}
# diagnostics
dg <- diagnostic_report(t, 0, U, particles, w, cfg)
out$diag_log[t, `:=`(t        = t,
ESS      = dg$ESS,
unique   = dg$unique,
euc      = dg$euc,
sparsity = dg$sparsity)]
# resample / move
if (ESS(w) < cfg$ess_thr * M && t < N) {
newAnc <- stratified_resample(w)
data_up_to_t <- U[max(1, t - cfg$W + 1):t, , drop = FALSE]
move_out <- resample_move_old(particles, newAnc, data_up_to_t, cl,
cfg$type, cfg, skeleton = skeleton)
particles <- move_out$particles
out$mh_acc_pct[t] <- move_out$acc_pct
if (cfg$adapt_step_sd) {
{cfg$step_sd <- compute_adapt_step_sd(cfg, move_out$acc_pct)}
out$step_sd_hist[t] <- cfg$step_sd
}
} else {
step_prev <- t - 1L
newAnc    <- if (step_prev < 1L) seq_len(M) else out$ancestorIndices[, step_prev]
}
out$ancestorIndices[, t] <- newAnc
# history arrays
out$fam_hist [ , t,] <- t(vapply(particles, `[[`, integer(K),"fam"))
out$par1_hist[, t,]  <- t(vapply(particles, `[[`, numeric(K),"th1"))
out$par2_hist[, t,]  <- t(vapply(particles, `[[`, numeric(K),"th2"))
}
# diagnostics
dg <- diagnostic_report(t, 0, U, particles, w, cfg)
tr-0
tr=0
q_probs = c(0.025, 0.975)
k_step     <- cfg$k_step
M          <- cfg$M
print_flag <- (t %% k_step == 0L) || (t == nrow(U))
fam_mat <- do.call(rbind, lapply(particles, `[[`, "fam"))
th1_mat <- do.call(rbind, lapply(particles, `[[`, "th1"))
th2_mat <- do.call(rbind, lapply(particles, `[[`, "th2"))
## family codes
IND  <- FAM_INDEP
GAU  <- FAM_GAUSS
BB1c <- FAM_BB1
BB1s <- FAM_BB1R180
BB8s <- FAM_BB8R180
BB7   <- FAM_BB7
BB7s  <- FAM_BB7R180
## weights & ESS
w_new <- w_new / sum(w_new)
ess_t <- 1 / sum(w_new^2)
w_new = w/sum(w)
## weights & ESS
w_new <- w_new / sum(w_new)
ess_t <- 1 / sum(w_new^2)
## sparsity etc.
dep_mask   <- fam_mat != IND
edge_ct    <- rowSums(dep_mask)
mean_edges <- w_mean(edge_ct, w_new)
se_edges   <- mc_se(edge_ct, w_new, ess_t)
sparsity   <- 1 - mean_edges / cfg$K
key_vec  <- apply(th1_mat, 1, \(row) paste(row, collapse = ","))
n_unique <- length(unique(key_vec))
dists    <- as.matrix(stats::dist(th1_mat))
avg_dist <- mean(dists[lower.tri(dists)])
if (print_flag) {
cat(sprintf(
"t=%4d | tr=%2d | ESS/M=%.3f | dep.edges=%.2f ± %.2f | sparsity=%.3f | unique=%d | L2=%.4f\n",
t, tr, ess_t / M, mean_edges, se_edges, sparsity, n_unique, avg_dist))
}
ess_t
w_new
w
log_inc
particles[[9]]
vine_j     <- fast_vine_from_particle(particles[[9]], skeleton)
u_row
u_t
dvinecop(u_t, vine_j)
vine_j
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
library(here)
source(here("src/R", "config.R"))
n_assets <- 1:7
n_days <- 1:3000
dat <- list(
U      = readRDS("data/PIT.rds")[1:length(n_days),n_assets],
mu_fc  = readRDS("data/returns_mean_forecast.rds")[n_days,(n_assets+1), with = FALSE],# [,-1],  # drop date col
sig_fc = readRDS("data/returns_vol_forecast.rds")[n_days,(n_assets+1), with = FALSE],  #[,-1],
df_fc = readRDS("data/df_fc.rds")[n_days,(n_assets+1), with = FALSE],#[,-1]
shape_fc = readRDS("data/shape_fc.rds")[n_days,(n_assets+1), with = FALSE],
y_real = readRDS("data/returns_actual.rds")[n_days,n_assets+1, with = FALSE]
)
cfg_variants <- list(list(label = "test"))
v=cfg_variants[1]
cfg <- modifyList(build_cfg(ncol(dat$U)), v[ setdiff(names(v),"label") ])
cfg$label <- v$label %||% "cfg"
set.seed(cfg$seed)
data = dat
